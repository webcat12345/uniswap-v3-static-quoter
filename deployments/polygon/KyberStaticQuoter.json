{
  "address": "0x6524fDB494679a12B2f1d1B051D8dEedB2E5cc25",
  "abi": [
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "_factory",
          "type": "address"
        }
      ],
      "stateMutability": "nonpayable",
      "type": "constructor"
    },
    {
      "inputs": [
        {
          "internalType": "address",
          "name": "poolAddress",
          "type": "address"
        },
        {
          "internalType": "bool",
          "name": "zeroForOne",
          "type": "bool"
        },
        {
          "internalType": "int256",
          "name": "amountSpecified",
          "type": "int256"
        },
        {
          "internalType": "uint160",
          "name": "sqrtPriceLimitX96",
          "type": "uint160"
        }
      ],
      "name": "quote",
      "outputs": [
        {
          "internalType": "int256",
          "name": "amount0",
          "type": "int256"
        },
        {
          "internalType": "int256",
          "name": "amount1",
          "type": "int256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "internalType": "bytes",
          "name": "path",
          "type": "bytes"
        },
        {
          "internalType": "uint256",
          "name": "amountIn",
          "type": "uint256"
        }
      ],
      "name": "quoteExactInput",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    },
    {
      "inputs": [
        {
          "components": [
            {
              "internalType": "address",
              "name": "tokenIn",
              "type": "address"
            },
            {
              "internalType": "address",
              "name": "tokenOut",
              "type": "address"
            },
            {
              "internalType": "uint256",
              "name": "amountIn",
              "type": "uint256"
            },
            {
              "internalType": "uint24",
              "name": "fee",
              "type": "uint24"
            },
            {
              "internalType": "uint160",
              "name": "sqrtPriceLimitX96",
              "type": "uint160"
            }
          ],
          "internalType": "struct IUniswapV3StaticQuoter.QuoteExactInputSingleParams",
          "name": "params",
          "type": "tuple"
        }
      ],
      "name": "quoteExactInputSingle",
      "outputs": [
        {
          "internalType": "uint256",
          "name": "amountOut",
          "type": "uint256"
        }
      ],
      "stateMutability": "view",
      "type": "function"
    }
  ],
  "transactionHash": "0x85715358d6b0bde31481d7c0756061962623a7fedf2534f05f94eea33669b5f1",
  "receipt": {
    "to": null,
    "from": "0x514580e65d55aEad40104Ca6a9Cd5e185AE2E857",
    "contractAddress": "0x6524fDB494679a12B2f1d1B051D8dEedB2E5cc25",
    "transactionIndex": 85,
    "gasUsed": "2146134",
    "logsBloom": "0x00000000000000000000000400000000000000000000000000000000000100000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000800000000000000000000100000000000000000000000000000002000000000000000000000000000080000000000000000000000000000200000000080000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000004000000000000000000001000000000000000000000000000000100000000000000000000002000000000000000000000000000000000000000000000000100000",
    "blockHash": "0x5da959eb10383e3ca50b55aadf524ca9166486b53b6bd252a1a3affc992e9c8f",
    "transactionHash": "0x85715358d6b0bde31481d7c0756061962623a7fedf2534f05f94eea33669b5f1",
    "logs": [
      {
        "transactionIndex": 85,
        "blockNumber": 35715904,
        "transactionHash": "0x85715358d6b0bde31481d7c0756061962623a7fedf2534f05f94eea33669b5f1",
        "address": "0x0000000000000000000000000000000000001010",
        "topics": [
          "0x4dfe1bbbcf077ddc3e01291eea2d5c70c2b422b415d95645b9adcfd678cb1d63",
          "0x0000000000000000000000000000000000000000000000000000000000001010",
          "0x000000000000000000000000514580e65d55aead40104ca6a9cd5e185ae2e857",
          "0x000000000000000000000000ec20607aa654d823dd01beb8780a44863c57ed07"
        ],
        "data": "0x00000000000000000000000000000000000000000000000002560bd75b9489ae000000000000000000000000000000000000000000000000b462464783bbecaf00000000000000000000000000000000000000000000010db71545cac670c777000000000000000000000000000000000000000000000000b20c3a702827630100000000000000000000000000000000000000000000010db96b51a222055125",
        "logIndex": 311,
        "blockHash": "0x5da959eb10383e3ca50b55aadf524ca9166486b53b6bd252a1a3affc992e9c8f"
      }
    ],
    "blockNumber": 35715904,
    "cumulativeGasUsed": "14607327",
    "status": 1,
    "byzantium": true
  },
  "args": [
    "0x5F1dddbf348aC2fbe22a163e30F99F9ECE3DD50a"
  ],
  "numDeployments": 1,
  "solcInputHash": "55894718e9f87dd457ef75e89327981e",
  "metadata": "{\"compiler\":{\"version\":\"0.7.6+commit.7338295f\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_factory\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"poolAddress\",\"type\":\"address\"},{\"internalType\":\"bool\",\"name\":\"zeroForOne\",\"type\":\"bool\"},{\"internalType\":\"int256\",\"name\":\"amountSpecified\",\"type\":\"int256\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"name\":\"quote\",\"outputs\":[{\"internalType\":\"int256\",\"name\":\"amount0\",\"type\":\"int256\"},{\"internalType\":\"int256\",\"name\":\"amount1\",\"type\":\"int256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"path\",\"type\":\"bytes\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"}],\"name\":\"quoteExactInput\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"components\":[{\"internalType\":\"address\",\"name\":\"tokenIn\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"tokenOut\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"amountIn\",\"type\":\"uint256\"},{\"internalType\":\"uint24\",\"name\":\"fee\",\"type\":\"uint24\"},{\"internalType\":\"uint160\",\"name\":\"sqrtPriceLimitX96\",\"type\":\"uint160\"}],\"internalType\":\"struct IUniswapV3StaticQuoter.QuoteExactInputSingleParams\",\"name\":\"params\",\"type\":\"tuple\"}],\"name\":\"quoteExactInputSingle\",\"outputs\":[{\"internalType\":\"uint256\",\"name\":\"amountOut\",\"type\":\"uint256\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"quoteExactInput(bytes,uint256)\":{\"params\":{\"amountIn\":\"The amount of the first token to swap\",\"path\":\"The path of the swap, i.e. each token pair and the pool fee\"},\"returns\":{\"amountOut\":\"The amount of the last token that would be received\"}},\"quoteExactInputSingle((address,address,uint256,uint24,uint160))\":{\"params\":{\"params\":\"The params for the quote, encoded as `QuoteExactInputSingleParams` tokenIn The token being swapped in tokenOut The token being swapped out fee The fee of the token pool to consider for the pair amountIn The desired input amount sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\"},\"returns\":{\"amountOut\":\"The amount of `tokenOut` that would be received\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"quoteExactInput(bytes,uint256)\":{\"notice\":\"Returns the amount out received for a given exact input swap without executing the swap\"},\"quoteExactInputSingle((address,address,uint256,uint24,uint160))\":{\"notice\":\"Returns the amount out received for a given exact input but for a swap of a single pool\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"contracts/KyberQuoter/KyberStaticQuoter.sol\":\"KyberStaticQuoter\"},\"evmVersion\":\"istanbul\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"none\",\"useLiteralContent\":true},\"optimizer\":{\"enabled\":true,\"runs\":1000000},\"remappings\":[]},\"sources\":{\"@uniswap/v3-core/contracts/libraries/TickMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0 <0.8.0;\\n\\n/// @title Math library for computing sqrt prices from ticks and vice versa\\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\\n/// prices between 2**-128 and 2**128\\nlibrary TickMath {\\n    /// @dev The minimum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**-128\\n    int24 internal constant MIN_TICK = -887272;\\n    /// @dev The maximum tick that may be passed to #getSqrtRatioAtTick computed from log base 1.0001 of 2**128\\n    int24 internal constant MAX_TICK = -MIN_TICK;\\n\\n    /// @dev The minimum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MIN_TICK)\\n    uint160 internal constant MIN_SQRT_RATIO = 4295128739;\\n    /// @dev The maximum value that can be returned from #getSqrtRatioAtTick. Equivalent to getSqrtRatioAtTick(MAX_TICK)\\n    uint160 internal constant MAX_SQRT_RATIO = 1461446703485210103287273052203988822378723970342;\\n\\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\\n    /// @dev Throws if |tick| > max tick\\n    /// @param tick The input tick for the above formula\\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the ratio of the two assets (token1/token0)\\n    /// at the given tick\\n    function getSqrtRatioAtTick(int24 tick) internal pure returns (uint160 sqrtPriceX96) {\\n        uint256 absTick = tick < 0 ? uint256(-int256(tick)) : uint256(int256(tick));\\n        require(absTick <= uint256(MAX_TICK), 'T');\\n\\n        uint256 ratio = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\\n        if (absTick & 0x2 != 0) ratio = (ratio * 0xfff97272373d413259a46990580e213a) >> 128;\\n        if (absTick & 0x4 != 0) ratio = (ratio * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\\n        if (absTick & 0x8 != 0) ratio = (ratio * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\\n        if (absTick & 0x10 != 0) ratio = (ratio * 0xffcb9843d60f6159c9db58835c926644) >> 128;\\n        if (absTick & 0x20 != 0) ratio = (ratio * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\\n        if (absTick & 0x40 != 0) ratio = (ratio * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\\n        if (absTick & 0x80 != 0) ratio = (ratio * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\\n        if (absTick & 0x100 != 0) ratio = (ratio * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\\n        if (absTick & 0x200 != 0) ratio = (ratio * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\\n        if (absTick & 0x400 != 0) ratio = (ratio * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\\n        if (absTick & 0x800 != 0) ratio = (ratio * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\\n        if (absTick & 0x1000 != 0) ratio = (ratio * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\\n        if (absTick & 0x2000 != 0) ratio = (ratio * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\\n        if (absTick & 0x4000 != 0) ratio = (ratio * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\\n        if (absTick & 0x8000 != 0) ratio = (ratio * 0x31be135f97d08fd981231505542fcfa6) >> 128;\\n        if (absTick & 0x10000 != 0) ratio = (ratio * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\\n        if (absTick & 0x20000 != 0) ratio = (ratio * 0x5d6af8dedb81196699c329225ee604) >> 128;\\n        if (absTick & 0x40000 != 0) ratio = (ratio * 0x2216e584f5fa1ea926041bedfe98) >> 128;\\n        if (absTick & 0x80000 != 0) ratio = (ratio * 0x48a170391f7dc42444e8fa2) >> 128;\\n\\n        if (tick > 0) ratio = type(uint256).max / ratio;\\n\\n        // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\\n        // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\\n        // we round up in the division so getTickAtSqrtRatio of the output price is always consistent\\n        sqrtPriceX96 = uint160((ratio >> 32) + (ratio % (1 << 32) == 0 ? 0 : 1));\\n    }\\n\\n    /// @notice Calculates the greatest tick value such that getRatioAtTick(tick) <= ratio\\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_RATIO, as MIN_SQRT_RATIO is the lowest value getRatioAtTick may\\n    /// ever return.\\n    /// @param sqrtPriceX96 The sqrt ratio for which to compute the tick as a Q64.96\\n    /// @return tick The greatest tick for which the ratio is less than or equal to the input ratio\\n    function getTickAtSqrtRatio(uint160 sqrtPriceX96) internal pure returns (int24 tick) {\\n        // second inequality must be < because the price can never reach the price at the max tick\\n        require(sqrtPriceX96 >= MIN_SQRT_RATIO && sqrtPriceX96 < MAX_SQRT_RATIO, 'R');\\n        uint256 ratio = uint256(sqrtPriceX96) << 32;\\n\\n        uint256 r = ratio;\\n        uint256 msb = 0;\\n\\n        assembly {\\n            let f := shl(7, gt(r, 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(6, gt(r, 0xFFFFFFFFFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(5, gt(r, 0xFFFFFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(4, gt(r, 0xFFFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(3, gt(r, 0xFF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(2, gt(r, 0xF))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := shl(1, gt(r, 0x3))\\n            msb := or(msb, f)\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            let f := gt(r, 0x1)\\n            msb := or(msb, f)\\n        }\\n\\n        if (msb >= 128) r = ratio >> (msb - 127);\\n        else r = ratio << (127 - msb);\\n\\n        int256 log_2 = (int256(msb) - 128) << 64;\\n\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(63, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(62, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(61, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(60, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(59, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(58, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(57, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(56, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(55, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(54, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(53, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(52, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(51, f))\\n            r := shr(f, r)\\n        }\\n        assembly {\\n            r := shr(127, mul(r, r))\\n            let f := shr(128, r)\\n            log_2 := or(log_2, shl(50, f))\\n        }\\n\\n        int256 log_sqrt10001 = log_2 * 255738958999603826347141; // 128.128 number\\n\\n        int24 tickLow = int24((log_sqrt10001 - 3402992956809132418596140100660247210) >> 128);\\n        int24 tickHi = int24((log_sqrt10001 + 291339464771989622907027621153398088495) >> 128);\\n\\n        tick = tickLow == tickHi ? tickLow : getSqrtRatioAtTick(tickHi) <= sqrtPriceX96 ? tickHi : tickLow;\\n    }\\n}\\n\",\"keccak256\":\"0xda8c2c0b12d2976acfd364453ba5f5bf0117ba3c91175ee9e1067d3fb26944d9\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-periphery/contracts/libraries/BytesLib.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\n/*\\n * @title Solidity Bytes Arrays Utils\\n * @author Gon\\u00e7alo S\\u00e1 <goncalo.sa@consensys.net>\\n *\\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\\n */\\npragma solidity >=0.5.0 <0.8.0;\\n\\nlibrary BytesLib {\\n    function slice(\\n        bytes memory _bytes,\\n        uint256 _start,\\n        uint256 _length\\n    ) internal pure returns (bytes memory) {\\n        require(_length + 31 >= _length, 'slice_overflow');\\n        require(_start + _length >= _start, 'slice_overflow');\\n        require(_bytes.length >= _start + _length, 'slice_outOfBounds');\\n\\n        bytes memory tempBytes;\\n\\n        assembly {\\n            switch iszero(_length)\\n                case 0 {\\n                    // Get a location of some free memory and store it in tempBytes as\\n                    // Solidity does for memory variables.\\n                    tempBytes := mload(0x40)\\n\\n                    // The first word of the slice result is potentially a partial\\n                    // word read from the original array. To read it, we calculate\\n                    // the length of that partial word and start copying that many\\n                    // bytes into the array. The first word we copy will start with\\n                    // data we don't care about, but the last `lengthmod` bytes will\\n                    // land at the beginning of the contents of the new array. When\\n                    // we're done copying, we overwrite the full first word with\\n                    // the actual length of the slice.\\n                    let lengthmod := and(_length, 31)\\n\\n                    // The multiplication in the next line is necessary\\n                    // because when slicing multiples of 32 bytes (lengthmod == 0)\\n                    // the following copy loop was copying the origin's length\\n                    // and then ending prematurely not copying everything it should.\\n                    let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\\n                    let end := add(mc, _length)\\n\\n                    for {\\n                        // The multiplication in the next line has the same exact purpose\\n                        // as the one above.\\n                        let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\\n                    } lt(mc, end) {\\n                        mc := add(mc, 0x20)\\n                        cc := add(cc, 0x20)\\n                    } {\\n                        mstore(mc, mload(cc))\\n                    }\\n\\n                    mstore(tempBytes, _length)\\n\\n                    //update free-memory pointer\\n                    //allocating the array padded to 32 bytes like the compiler does now\\n                    mstore(0x40, and(add(mc, 31), not(31)))\\n                }\\n                //if we want a zero-length slice let's just return a zero-length array\\n                default {\\n                    tempBytes := mload(0x40)\\n                    //zero out the 32 bytes slice we are about to return\\n                    //we need to do it because Solidity does not garbage collect\\n                    mstore(tempBytes, 0)\\n\\n                    mstore(0x40, add(tempBytes, 0x20))\\n                }\\n        }\\n\\n        return tempBytes;\\n    }\\n\\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\\n        require(_start + 20 >= _start, 'toAddress_overflow');\\n        require(_bytes.length >= _start + 20, 'toAddress_outOfBounds');\\n        address tempAddress;\\n\\n        assembly {\\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\\n        }\\n\\n        return tempAddress;\\n    }\\n\\n    function toUint24(bytes memory _bytes, uint256 _start) internal pure returns (uint24) {\\n        require(_start + 3 >= _start, 'toUint24_overflow');\\n        require(_bytes.length >= _start + 3, 'toUint24_outOfBounds');\\n        uint24 tempUint;\\n\\n        assembly {\\n            tempUint := mload(add(add(_bytes, 0x3), _start))\\n        }\\n\\n        return tempUint;\\n    }\\n}\\n\",\"keccak256\":\"0x68629e5b1a30b6490c6ae721c28117f6f963745462b007da0769758eb67f10d4\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-periphery/contracts/libraries/Path.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.6.0;\\n\\nimport './BytesLib.sol';\\n\\n/// @title Functions for manipulating path data for multihop swaps\\nlibrary Path {\\n    using BytesLib for bytes;\\n\\n    /// @dev The length of the bytes encoded address\\n    uint256 private constant ADDR_SIZE = 20;\\n    /// @dev The length of the bytes encoded fee\\n    uint256 private constant FEE_SIZE = 3;\\n\\n    /// @dev The offset of a single token address and pool fee\\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE + FEE_SIZE;\\n    /// @dev The offset of an encoded pool key\\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\\n    /// @dev The minimum length of an encoding that contains 2 or more pools\\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\\n\\n    /// @notice Returns true iff the path contains two or more pools\\n    /// @param path The encoded swap path\\n    /// @return True if path contains two or more pools, otherwise false\\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\\n    }\\n\\n    /// @notice Returns the number of pools in the path\\n    /// @param path The encoded swap path\\n    /// @return The number of pools in the path\\n    function numPools(bytes memory path) internal pure returns (uint256) {\\n        // Ignore the first token address. From then on every fee and token offset indicates a pool.\\n        return ((path.length - ADDR_SIZE) / NEXT_OFFSET);\\n    }\\n\\n    /// @notice Decodes the first pool in path\\n    /// @param path The bytes encoded swap path\\n    /// @return tokenA The first token of the given pool\\n    /// @return tokenB The second token of the given pool\\n    /// @return fee The fee level of the pool\\n    function decodeFirstPool(bytes memory path)\\n        internal\\n        pure\\n        returns (\\n            address tokenA,\\n            address tokenB,\\n            uint24 fee\\n        )\\n    {\\n        tokenA = path.toAddress(0);\\n        fee = path.toUint24(ADDR_SIZE);\\n        tokenB = path.toAddress(NEXT_OFFSET);\\n    }\\n\\n    /// @notice Gets the segment corresponding to the first pool in the path\\n    /// @param path The bytes encoded swap path\\n    /// @return The segment containing all data necessary to target the first pool in the path\\n    function getFirstPool(bytes memory path) internal pure returns (bytes memory) {\\n        return path.slice(0, POP_OFFSET);\\n    }\\n\\n    /// @notice Skips a token + fee element from the buffer and returns the remainder\\n    /// @param path The swap path\\n    /// @return The remaining token + fee elements in the path\\n    function skipToken(bytes memory path) internal pure returns (bytes memory) {\\n        return path.slice(NEXT_OFFSET, path.length - NEXT_OFFSET);\\n    }\\n}\\n\",\"keccak256\":\"0xb22c562b5175d50dbcc2224325666090d985f052abdcfe275c8dfc884e34de61\",\"license\":\"GPL-2.0-or-later\"},\"@uniswap/v3-periphery/contracts/libraries/PoolAddress.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\npragma solidity >=0.5.0;\\n\\n/// @title Provides functions for deriving a pool address from the factory, tokens, and the fee\\nlibrary PoolAddress {\\n    bytes32 internal constant POOL_INIT_CODE_HASH = 0xe34f199b19b2b4f47f68442619d555527d244f78a3297ea89325f843f87b8b54;\\n\\n    /// @notice The identifying key of the pool\\n    struct PoolKey {\\n        address token0;\\n        address token1;\\n        uint24 fee;\\n    }\\n\\n    /// @notice Returns PoolKey: the ordered tokens with the matched fee levels\\n    /// @param tokenA The first token of a pool, unsorted\\n    /// @param tokenB The second token of a pool, unsorted\\n    /// @param fee The fee level of the pool\\n    /// @return Poolkey The pool details with ordered token0 and token1 assignments\\n    function getPoolKey(\\n        address tokenA,\\n        address tokenB,\\n        uint24 fee\\n    ) internal pure returns (PoolKey memory) {\\n        if (tokenA > tokenB) (tokenA, tokenB) = (tokenB, tokenA);\\n        return PoolKey({token0: tokenA, token1: tokenB, fee: fee});\\n    }\\n\\n    /// @notice Deterministically computes the pool address given the factory and PoolKey\\n    /// @param factory The Uniswap V3 factory contract address\\n    /// @param key The PoolKey\\n    /// @return pool The contract address of the V3 pool\\n    function computeAddress(address factory, PoolKey memory key) internal pure returns (address pool) {\\n        require(key.token0 < key.token1);\\n        pool = address(\\n            uint256(\\n                keccak256(\\n                    abi.encodePacked(\\n                        hex'ff',\\n                        factory,\\n                        keccak256(abi.encode(key.token0, key.token1, key.fee)),\\n                        POOL_INIT_CODE_HASH\\n                    )\\n                )\\n            )\\n        );\\n    }\\n}\\n\",\"keccak256\":\"0x5edd84eb8ba7c12fd8cb6cffe52e1e9f3f6464514ee5f539c2283826209035a2\",\"license\":\"GPL-2.0-or-later\"},\"contracts/IUniV3likeQuoterCore.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity =0.7.6;\\r\\n\\r\\nstruct GlobalState {\\r\\n    uint160 startPrice;\\r\\n    int24 startTick;\\r\\n    uint16 fee;\\r\\n}\\r\\n\\r\\n// the top level state of the swap, the results of which are recorded in storage at the end\\r\\nstruct SwapState {\\r\\n    // the amount remaining to be swapped in/out of the input/output asset\\r\\n    int256 amountSpecifiedRemaining;\\r\\n    // the amount already swapped out/in of the output/input asset\\r\\n    int256 amountCalculated;\\r\\n    // current sqrt(price)\\r\\n    uint160 sqrtPriceX96;\\r\\n    // the tick associated with the current price\\r\\n    int24 tick;\\r\\n    // the current liquidity in range\\r\\n    uint128 liquidity;\\r\\n}\\r\\n\\r\\nstruct StepComputations {\\r\\n    // the price at the beginning of the step\\r\\n    uint160 sqrtPriceStartX96;\\r\\n    // the next tick to swap to from the current tick in the swap direction\\r\\n    int24 tickNext;\\r\\n    // whether tickNext is initialized or not\\r\\n    bool initialized;\\r\\n    // sqrt(price) for the next tick (1/0)\\r\\n    uint160 sqrtPriceNextX96;\\r\\n    // how much is being swapped in in this step\\r\\n    uint256 amountIn;\\r\\n    // how much is being swapped out\\r\\n    uint256 amountOut;\\r\\n    // how much fee is being paid in\\r\\n    uint256 feeAmount;\\r\\n}\\r\\n\\r\\ninterface IUniV3likeQuoterCore {\\r\\n\\r\\n    function quote(\\r\\n        address poolAddress,\\r\\n        bool zeroForOne,\\r\\n        int256 amountSpecified,\\r\\n        uint160 sqrtPriceLimitX96\\r\\n    ) external view returns (int256 amount0, int256 amount1);\\r\\n\\r\\n}\",\"keccak256\":\"0x32505c22797509e2fe5efa5bcebae162b27fb34767ffe0080fbbf7bebab28744\",\"license\":\"GPL-2.0-or-later\"},\"contracts/KyberQuoter/KyberQuoterCore.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity =0.7.6;\\r\\n\\r\\nimport '@uniswap/v3-core/contracts/libraries/TickMath.sol';\\r\\n\\r\\nimport './interfaces/IKyberQuoterCore.sol';\\r\\nimport './interfaces/IKyberPool.sol';\\r\\nimport './lib/SwapMath.sol';\\r\\nimport './lib/SafeCast.sol';\\r\\n\\r\\n\\r\\ncontract KyberQuoterCore {\\r\\n    using SafeCast for uint256;\\r\\n    using SafeCast for int128;\\r\\n\\r\\n    function quote(\\r\\n        address poolAddress,\\r\\n        bool zeroForOne,\\r\\n        int256 amountSpecified,\\r\\n        uint160 sqrtPriceLimitX96\\r\\n    ) public view returns (int256 amount0, int256 amount1) {\\r\\n        require(amountSpecified != 0, 'amountSpecified cannot be zero');\\r\\n\\r\\n        SwapData memory swapData;\\r\\n        swapData.specifiedAmount = amountSpecified;\\r\\n        swapData.isToken0 = zeroForOne;\\r\\n        swapData.isExactInput = swapData.specifiedAmount > 0;\\r\\n        // tick (token1Qty/token0Qty) will increase for swapping from token1 to token0\\r\\n        bool willUpTick = (swapData.isExactInput != zeroForOne);\\r\\n        (\\r\\n            swapData.baseL,\\r\\n            swapData.reinvestL,\\r\\n            swapData.sqrtP,\\r\\n            swapData.currentTick,\\r\\n            swapData.nextTick\\r\\n        ) = getInitialSwapData(poolAddress, willUpTick);\\r\\n        checkSqrtPriceLimitWithinAllowed(willUpTick, sqrtPriceLimitX96, swapData.sqrtP);\\r\\n        uint24 swapFeeUnits = IKyberPool(poolAddress).swapFeeUnits();\\r\\n\\r\\n        // continue swapping while specified input/output isn't satisfied or price limit not reached\\r\\n        while (swapData.specifiedAmount != 0 && swapData.sqrtP != sqrtPriceLimitX96) {\\r\\n            int24 tempNextTick = getTempNextTick(swapData.currentTick, swapData.nextTick, willUpTick);\\r\\n            swapData.nextSqrtP = TickMath.getSqrtRatioAtTick(tempNextTick);\\r\\n\\r\\n            // local scope for targetSqrtP, usedAmount, returnedAmount and deltaL\\r\\n            {\\r\\n                uint160 targetSqrtP = swapData.nextSqrtP;\\r\\n                // ensure next sqrtP (and its corresponding tick) does not exceed price limit\\r\\n                if (willUpTick == (swapData.nextSqrtP > sqrtPriceLimitX96))\\r\\n                    targetSqrtP = sqrtPriceLimitX96;\\r\\n\\r\\n                int256 usedAmount;\\r\\n                int256 returnedAmount;\\r\\n                uint256 deltaL;\\r\\n                (usedAmount, returnedAmount, deltaL, swapData.sqrtP) = SwapMath.computeSwapStep(\\r\\n                    swapData.baseL + swapData.reinvestL,\\r\\n                    swapData.sqrtP,\\r\\n                    targetSqrtP,\\r\\n                    swapFeeUnits,\\r\\n                    swapData.specifiedAmount,\\r\\n                    swapData.isExactInput,\\r\\n                    swapData.isToken0\\r\\n                );\\r\\n\\r\\n                swapData.specifiedAmount -= usedAmount;\\r\\n                swapData.returnedAmount += returnedAmount;\\r\\n                swapData.reinvestL += deltaL.toUint128();\\r\\n            }\\r\\n\\r\\n            // if price has not reached the next sqrt price\\r\\n            if (swapData.sqrtP != swapData.nextSqrtP) {\\r\\n                swapData.currentTick = TickMath.getTickAtSqrtRatio(swapData.sqrtP);\\r\\n                break;\\r\\n            }\\r\\n            swapData.currentTick = willUpTick ? tempNextTick : tempNextTick - 1;\\r\\n            // if tempNextTick is not next initialized tick\\r\\n            if (tempNextTick != swapData.nextTick)\\r\\n                continue;\\r\\n            (swapData.baseL, swapData.nextTick) = _updateLiquidityAndCrossTick(\\r\\n                poolAddress,\\r\\n                swapData.nextTick,\\r\\n                swapData.baseL,\\r\\n                willUpTick\\r\\n            );\\r\\n        }\\r\\n\\r\\n        (amount0, amount1) = zeroForOne\\r\\n            ? (amountSpecified - swapData.specifiedAmount, swapData.returnedAmount)\\r\\n            : (swapData.returnedAmount, amountSpecified - swapData.specifiedAmount);\\r\\n\\r\\n    }\\r\\n\\r\\n    function getInitialSwapData(\\r\\n        address poolAddress,\\r\\n        bool willUpTick\\r\\n    ) internal view returns (\\r\\n        uint128 baseL,\\r\\n        uint128 reinvestL,\\r\\n        uint160 sqrtP,\\r\\n        int24 currentTick,\\r\\n        int24 nextTick\\r\\n    ) {\\r\\n        (sqrtP, currentTick, nextTick,) = IKyberPool(poolAddress).getPoolState();\\r\\n        (baseL, reinvestL,) = IKyberPool(poolAddress).getLiquidityState();\\r\\n        if (willUpTick)\\r\\n            nextTick = getNextInitializedTick(poolAddress, nextTick);\\r\\n    }\\r\\n\\r\\n    function checkSqrtPriceLimitWithinAllowed(\\r\\n        bool willUpTick,\\r\\n        uint160 sqrtPriceLimit, \\r\\n        uint160 sqrtP\\r\\n    ) internal pure {\\r\\n        bool withinAllowed = willUpTick\\r\\n            ? sqrtPriceLimit > sqrtP && sqrtPriceLimit < TickMath.MAX_SQRT_RATIO\\r\\n            : sqrtPriceLimit < sqrtP && sqrtPriceLimit > TickMath.MIN_SQRT_RATIO;\\r\\n        require(withinAllowed, 'sqrtPriceLimit out of bounds');\\r\\n    }\\r\\n\\r\\n    function getTempNextTick(\\r\\n        int24 currentTick, \\r\\n        int24 nextTick, \\r\\n        bool willUpTick\\r\\n    ) internal pure returns (int24 tempNextTick) {\\r\\n        // math calculations work with the assumption that the price diff is capped to 5%\\r\\n        // since tick distance is uncapped between currentTick and nextTick\\r\\n        // we use tempNextTick to satisfy our assumption with MAX_TICK_DISTANCE is set to be matched this condition\\r\\n        tempNextTick = nextTick;\\r\\n        if (willUpTick && tempNextTick > MAX_TICK_DISTANCE + currentTick)\\r\\n            tempNextTick = currentTick + MAX_TICK_DISTANCE;\\r\\n        else if (!willUpTick && tempNextTick < currentTick - MAX_TICK_DISTANCE)\\r\\n            tempNextTick = currentTick - MAX_TICK_DISTANCE;\\r\\n    }\\r\\n\\r\\n    /// @dev Update liquidity net data and do cross tick\\r\\n    function _updateLiquidityAndCrossTick(\\r\\n        address poolAddress,\\r\\n        int24 nextTick,\\r\\n        uint128 currentLiquidity,\\r\\n        bool willUpTick\\r\\n    ) internal view returns (uint128 newLiquidity, int24 newNextTick) {\\r\\n        (,int128 liquidityNet,,) = IKyberPool(poolAddress).ticks(nextTick);\\r\\n        if (willUpTick) {\\r\\n            (,newNextTick) = IKyberPool(poolAddress).initializedTicks(nextTick);\\r\\n        } else {\\r\\n            (newNextTick,) = IKyberPool(poolAddress).initializedTicks(nextTick);\\r\\n            liquidityNet = -liquidityNet;\\r\\n        }\\r\\n        newLiquidity = LiqDeltaMath.applyLiquidityDelta(\\r\\n            currentLiquidity,\\r\\n            liquidityNet >= 0 ? uint128(liquidityNet) : liquidityNet.revToUint128(),\\r\\n            liquidityNet >= 0\\r\\n        );\\r\\n    }\\r\\n\\r\\n    function getNextInitializedTick(\\r\\n        address poolAddress, \\r\\n        int24 tick\\r\\n    ) internal view returns (int24 next) {\\r\\n        (,next) = IKyberPool(poolAddress).initializedTicks(tick);\\r\\n    }\\r\\n\\r\\n}\\r\\n\",\"keccak256\":\"0x909b38f322f75585b23cbdcefc8bdc38b3b9a62c58e0df19785ec3eb93624097\",\"license\":\"GPL-2.0-or-later\"},\"contracts/KyberQuoter/KyberStaticQuoter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity =0.7.6;\\r\\npragma abicoder v2;\\r\\n\\r\\nimport '@uniswap/v3-periphery/contracts/libraries/PoolAddress.sol';\\r\\nimport '@uniswap/v3-periphery/contracts/libraries/Path.sol';\\r\\n\\r\\nimport '../UniV3Quoter/interfaces/IUniswapV3StaticQuoter.sol';\\r\\nimport './interfaces/IKyberFactory.sol';\\r\\nimport './KyberQuoterCore.sol';\\r\\n\\r\\ncontract KyberStaticQuoter is IUniswapV3StaticQuoter, KyberQuoterCore {\\r\\n    using SafeCast for uint256;\\r\\n    using Path for bytes;\\r\\n\\r\\n    address immutable factory;\\r\\n\\r\\n    constructor(address _factory) {\\r\\n        factory = _factory;\\r\\n    }\\r\\n\\r\\n    function getPool(\\r\\n        address tokenA,\\r\\n        address tokenB,\\r\\n        uint24 fee\\r\\n    ) private view returns (address) {\\r\\n        return IKyberFactory(factory).getPool(tokenA, tokenB, fee);\\r\\n    }\\r\\n\\r\\n    function quoteExactInputSingle(QuoteExactInputSingleParams memory params)\\r\\n        public\\r\\n        view\\r\\n        override\\r\\n        returns (uint256 amountOut)\\r\\n    {\\r\\n        bool zeroForOne = params.tokenIn < params.tokenOut;\\r\\n        address pool = getPool(params.tokenIn, params.tokenOut, params.fee);\\r\\n        require(pool != address(0), 'Pool not found');\\r\\n        (int256 amount0, int256 amount1) = quote(\\r\\n            pool,\\r\\n            zeroForOne,\\r\\n            params.amountIn.toInt256(),\\r\\n            params.sqrtPriceLimitX96 == 0\\r\\n                ? (zeroForOne ? TickMath.MIN_SQRT_RATIO + 1 : TickMath.MAX_SQRT_RATIO - 1)\\r\\n                : params.sqrtPriceLimitX96\\r\\n        );\\r\\n\\r\\n        return zeroForOne ? uint256(-amount1) : uint256(-amount0);\\r\\n    }\\r\\n\\r\\n    function quoteExactInput(bytes memory path, uint256 amountIn)\\r\\n        public\\r\\n        view\\r\\n        override\\r\\n        returns (uint256 amountOut)\\r\\n    {\\r\\n        uint256 i = 0;\\r\\n        while (true) {\\r\\n            (address tokenIn, address tokenOut, uint24 fee) = path.decodeFirstPool();\\r\\n\\r\\n            // the outputs of prior swaps become the inputs to subsequent ones\\r\\n            uint256 _amountOut =\\r\\n                quoteExactInputSingle(\\r\\n                    QuoteExactInputSingleParams({\\r\\n                        tokenIn: tokenIn,\\r\\n                        tokenOut: tokenOut,\\r\\n                        fee: fee,\\r\\n                        amountIn: amountIn,\\r\\n                        sqrtPriceLimitX96: 0\\r\\n                    })\\r\\n                );\\r\\n\\r\\n            amountIn = _amountOut;\\r\\n            i++;\\r\\n\\r\\n            // decide whether to continue or terminate\\r\\n            if (path.hasMultiplePools()) {\\r\\n                path = path.skipToken();\\r\\n            } else {\\r\\n                return amountIn;\\r\\n            }\\r\\n        }\\r\\n    }\\r\\n}\\r\\n\",\"keccak256\":\"0x96eb006147309067e2807eca932d662713c1298468fcf7a6d7a1815a4eb7e357\",\"license\":\"GPL-2.0-or-later\"},\"contracts/KyberQuoter/interfaces/IKyberFactory.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.7.5;\\r\\npragma abicoder v2;\\r\\n\\r\\n\\r\\ninterface IKyberFactory {\\r\\n\\r\\n    /// @notice Fetches the recipient of government fees\\r\\n    /// and current government fee charged in fee units\\r\\n    function feeConfiguration() external view returns (address _feeTo, uint24 _governmentFeeUnits);\\r\\n    function getPool(address, address, uint24) external view returns (address);\\r\\n}\",\"keccak256\":\"0x4c8344cd7bd741d0e24c1323129b5f1ae2707d9efea20e0dcd816bbcf05bcfe4\",\"license\":\"GPL-2.0-or-later\"},\"contracts/KyberQuoter/interfaces/IKyberPool.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.7.5;\\r\\npragma abicoder v2;\\r\\n\\r\\n\\r\\ninterface IKyberPool {\\r\\n\\r\\n    /// @notice The fee to be charged for a swap in basis points\\r\\n    /// @return The swap fee in basis points\\r\\n    function swapFeeUnits() external view returns (uint24);\\r\\n\\r\\n    /// @notice The pool tick distance\\r\\n    /// @dev Ticks can only be initialized and used at multiples of this value\\r\\n    /// It remains an int24 to avoid casting even though it is >= 1.\\r\\n    /// e.g: a tickDistance of 5 means ticks can be initialized every 5th tick, i.e., ..., -10, -5, 0, 5, 10, ...\\r\\n    /// @return The tick distance\\r\\n    function tickDistance() external view returns (int24);\\r\\n\\r\\n    /// @notice Fetches the pool's liquidity values\\r\\n    /// @return baseL pool's base liquidity without reinvest liqudity\\r\\n    /// @return reinvestL the liquidity is reinvested into the pool\\r\\n    /// @return reinvestLLast last cached value of reinvestL, used for calculating reinvestment token qty\\r\\n    function getLiquidityState()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint128 baseL,\\r\\n            uint128 reinvestL,\\r\\n            uint128 reinvestLLast\\r\\n        );\\r\\n\\r\\n    /// @notice Fetches the pool's prices, ticks and lock status\\r\\n    /// @return sqrtP sqrt of current price: sqrt(token1/token0)\\r\\n    /// @return currentTick pool's current tick\\r\\n    /// @return nearestCurrentTick pool's nearest initialized tick that is <= currentTick\\r\\n    /// @return locked true if pool is locked, false otherwise\\r\\n    function getPoolState()\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint160 sqrtP,\\r\\n            int24 currentTick,\\r\\n            int24 nearestCurrentTick,\\r\\n            bool locked\\r\\n        );\\r\\n\\r\\n    function factory() external view returns (address);\\r\\n\\r\\n    /// @return feeGrowthGlobal All-time fee growth per unit of liquidity of the pool\\r\\n    function getFeeGrowthGlobal() external view returns (uint256);\\r\\n\\r\\n    function ticks(int24 tick)\\r\\n        external\\r\\n        view\\r\\n        returns (\\r\\n            uint128 liquidityGross,\\r\\n            int128 liquidityNet,\\r\\n            uint256 feeGrowthOutside,\\r\\n            uint128 secondsPerLiquidityOutside\\r\\n        );\\r\\n\\r\\n    /// @notice Returns the previous and next initialized ticks of a specific tick\\r\\n    /// @dev If specified tick is uninitialized, the returned values are zero.\\r\\n    /// @param tick The tick to look up\\r\\n    function initializedTicks(int24 tick) external view returns (int24 previous, int24 next);\\r\\n\\r\\n    function totalSupply() external view returns (uint256);\\r\\n    function getSecondsPerLiquidityData() external view returns (uint128 secondsPerLiquidityGlobal, uint32 lastUpdateTime);\\r\\n\\r\\n}\",\"keccak256\":\"0x0f7a464c83fd79e35035fd55b2ed676ce8c06e0d345c4251bcc0102d96b93f89\",\"license\":\"GPL-2.0-or-later\"},\"contracts/KyberQuoter/interfaces/IKyberQuoterCore.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity =0.7.6;\\r\\n\\r\\nimport { IUniV3likeQuoterCore } from '../../IUniV3likeQuoterCore.sol';\\r\\n\\r\\n// temporary swap variables, some of which will be used to update the pool state\\r\\nstruct SwapData {\\r\\n    int256 specifiedAmount; // the specified amount (could be tokenIn or tokenOut)\\r\\n    int256 returnedAmount; // the opposite amout of sourceQty\\r\\n    uint160 sqrtP; // current sqrt(price), multiplied by 2^96\\r\\n    int24 currentTick; // the tick associated with the current price\\r\\n    int24 nextTick; // the next initialized tick\\r\\n    uint160 nextSqrtP; // the price of nextTick\\r\\n    bool isToken0; // true if specifiedAmount is in token0, false if in token1\\r\\n    bool isExactInput; // true = input qty, false = output qty\\r\\n    uint128 baseL; // the cached base pool liquidity without reinvestment liquidity\\r\\n    uint128 reinvestL; // the cached reinvestment liquidity\\r\\n}\\r\\n\\r\\ninterface IKyberQuoterCore is IUniV3likeQuoterCore {}\",\"keccak256\":\"0x1e758e3adad291063a424c5a04222b23ce3bfaf3af2c7053c3564ea0c911b3d3\",\"license\":\"GPL-2.0-or-later\"},\"contracts/KyberQuoter/lib/FullMath.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity =0.7.6;\\r\\n\\r\\n/// @title Contains 512-bit math functions\\r\\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\\r\\n/// @dev Handles \\\"phantom overflow\\\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\\r\\n/// @dev Code has been modified to be compatible with sol 0.8\\r\\nlibrary FullMath {\\r\\n  /// @notice Calculates floor(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\r\\n  /// @param a The multiplicand\\r\\n  /// @param b The multiplier\\r\\n  /// @param denominator The divisor\\r\\n  /// @return result The 256-bit result\\r\\n  /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\\r\\n  function mulDivFloor(\\r\\n    uint256 a,\\r\\n    uint256 b,\\r\\n    uint256 denominator\\r\\n  ) internal pure returns (uint256 result) {\\r\\n    // 512-bit multiply [prod1 prod0] = a * b\\r\\n    // Compute the product mod 2**256 and mod 2**256 - 1\\r\\n    // then use the Chinese Remainder Theorem to reconstruct\\r\\n    // the 512 bit result. The result is stored in two 256\\r\\n    // variables such that product = prod1 * 2**256 + prod0\\r\\n    uint256 prod0; // Least significant 256 bits of the product\\r\\n    uint256 prod1; // Most significant 256 bits of the product\\r\\n    assembly {\\r\\n      let mm := mulmod(a, b, not(0))\\r\\n      prod0 := mul(a, b)\\r\\n      prod1 := sub(sub(mm, prod0), lt(mm, prod0))\\r\\n    }\\r\\n\\r\\n    // Handle non-overflow cases, 256 by 256 division\\r\\n    if (prod1 == 0) {\\r\\n      require(denominator > 0, '0 denom');\\r\\n      assembly {\\r\\n        result := div(prod0, denominator)\\r\\n      }\\r\\n      return result;\\r\\n    }\\r\\n\\r\\n    // Make sure the result is less than 2**256.\\r\\n    // Also prevents denominator == 0\\r\\n    require(denominator > prod1, 'denom <= prod1');\\r\\n\\r\\n    ///////////////////////////////////////////////\\r\\n    // 512 by 256 division.\\r\\n    ///////////////////////////////////////////////\\r\\n\\r\\n    // Make division exact by subtracting the remainder from [prod1 prod0]\\r\\n    // Compute remainder using mulmod\\r\\n    uint256 remainder;\\r\\n    assembly {\\r\\n      remainder := mulmod(a, b, denominator)\\r\\n    }\\r\\n    // Subtract 256 bit number from 512 bit number\\r\\n    assembly {\\r\\n      prod1 := sub(prod1, gt(remainder, prod0))\\r\\n      prod0 := sub(prod0, remainder)\\r\\n    }\\r\\n\\r\\n    // Factor powers of two out of denominator\\r\\n    // Compute largest power of two divisor of denominator.\\r\\n    // Always >= 1.\\r\\n    uint256 twos = denominator & (~denominator + 1);\\r\\n    // Divide denominator by power of two\\r\\n    assembly {\\r\\n      denominator := div(denominator, twos)\\r\\n    }\\r\\n\\r\\n    // Divide [prod1 prod0] by the factors of two\\r\\n    assembly {\\r\\n      prod0 := div(prod0, twos)\\r\\n    }\\r\\n    // Shift in bits from prod1 into prod0. For this we need\\r\\n    // to flip `twos` such that it is 2**256 / twos.\\r\\n    // If twos is zero, then it becomes one\\r\\n    assembly {\\r\\n      twos := add(div(sub(0, twos), twos), 1)\\r\\n    }\\r\\n    prod0 |= prod1 * twos;\\r\\n\\r\\n    // Invert denominator mod 2**256\\r\\n    // Now that denominator is an odd number, it has an inverse\\r\\n    // modulo 2**256 such that denominator * inv = 1 mod 2**256.\\r\\n    // Compute the inverse by starting with a seed that is correct\\r\\n    // correct for four bits. That is, denominator * inv = 1 mod 2**4\\r\\n    uint256 inv = (3 * denominator) ^ 2;\\r\\n\\r\\n    // Now use Newton-Raphson iteration to improve the precision.\\r\\n    // Thanks to Hensel's lifting lemma, this also works in modular\\r\\n    // arithmetic, doubling the correct bits in each step.\\r\\n    inv *= 2 - denominator * inv; // inverse mod 2**8\\r\\n    inv *= 2 - denominator * inv; // inverse mod 2**16\\r\\n    inv *= 2 - denominator * inv; // inverse mod 2**32\\r\\n    inv *= 2 - denominator * inv; // inverse mod 2**64\\r\\n    inv *= 2 - denominator * inv; // inverse mod 2**128\\r\\n    inv *= 2 - denominator * inv; // inverse mod 2**256\\r\\n\\r\\n    // Because the division is now exact we can divide by multiplying\\r\\n    // with the modular inverse of denominator. This will give us the\\r\\n    // correct result modulo 2**256. Since the precoditions guarantee\\r\\n    // that the outcome is less than 2**256, this is the final result.\\r\\n    // We don't need to compute the high bits of the result and prod1\\r\\n    // is no longer required.\\r\\n    result = prod0 * inv;\\r\\n    return result;\\r\\n  }\\r\\n\\r\\n  /// @notice Calculates ceil(a\\u00d7b\\u00f7denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\\r\\n  /// @param a The multiplicand\\r\\n  /// @param b The multiplier\\r\\n  /// @param denominator The divisor\\r\\n  /// @return result The 256-bit result\\r\\n  function mulDivCeiling(\\r\\n    uint256 a,\\r\\n    uint256 b,\\r\\n    uint256 denominator\\r\\n  ) internal pure returns (uint256 result) {\\r\\n    result = mulDivFloor(a, b, denominator);\\r\\n    if (mulmod(a, b, denominator) > 0) {\\r\\n      result++;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"keccak256\":\"0xafadc39ded0714a54e0f2dad16c85bf49a492ab5802bba370dd644374242e0ac\",\"license\":\"GPL-2.0-or-later\"},\"contracts/KyberQuoter/lib/Math.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity =0.7.6;\\r\\n\\r\\nimport './FullMath.sol';\\r\\n\\r\\nuint256 constant TWO_FEE_UNITS = 200_000;\\r\\nuint256 constant TWO_POW_96 = 2**96;\\r\\nuint128 constant MIN_LIQUIDITY = 100000;\\r\\nuint8 constant RES_96 = 96;\\r\\nuint24 constant BPS = 10000;\\r\\nuint24 constant FEE_UNITS = 100000;\\r\\n// it is strictly less than 5% price movement if jumping MAX_TICK_DISTANCE ticks\\r\\nint24 constant MAX_TICK_DISTANCE = 480;\\r\\n// max number of tick travel when inserting if data changes\\r\\nuint256 constant MAX_TICK_TRAVEL = 10;\\r\\n\\r\\n/// @title Contains helper function to add or remove uint128 liquidityDelta to uint128 liquidity\\r\\nlibrary LiqDeltaMath {\\r\\n  function applyLiquidityDelta(\\r\\n    uint128 liquidity,\\r\\n    uint128 liquidityDelta,\\r\\n    bool isAddLiquidity\\r\\n  ) internal pure returns (uint128) {\\r\\n    return isAddLiquidity ? liquidity + liquidityDelta : liquidity - liquidityDelta;\\r\\n  }\\r\\n}\",\"keccak256\":\"0x7ea833727a9b3805306bfc6ce3738c967934b9f85d3f8cd10c8a2039f4da7029\",\"license\":\"GPL-2.0-or-later\"},\"contracts/KyberQuoter/lib/SafeCast.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.7.6;\\r\\n\\r\\n/// @title Safe casting methods\\r\\n/// @notice Contains methods for safely casting between types\\r\\nlibrary SafeCast {\\r\\n  /// @notice Cast a uint256 to uint32, revert on overflow\\r\\n  /// @param y The uint256 to be downcasted\\r\\n  /// @return z The downcasted integer, now type uint32\\r\\n  function toUint32(uint256 y) internal pure returns (uint32 z) {\\r\\n    require((z = uint32(y)) == y);\\r\\n  }\\r\\n\\r\\n  /// @notice Cast a uint128 to a int128, revert on overflow\\r\\n  /// @param y The uint256 to be casted\\r\\n  /// @return z The casted integer, now type int256\\r\\n  function toInt128(uint128 y) internal pure returns (int128 z) {\\r\\n    require(y < 2**127);\\r\\n    z = int128(y);\\r\\n  }\\r\\n\\r\\n  /// @notice Cast a uint256 to a uint128, revert on overflow\\r\\n  /// @param y the uint256 to be downcasted\\r\\n  /// @return z The downcasted integer, now type uint128\\r\\n  function toUint128(uint256 y) internal pure returns (uint128 z) {\\r\\n    require((z = uint128(y)) == y);\\r\\n  }\\r\\n\\r\\n  /// @notice Cast a int128 to a uint128 and reverses the sign.\\r\\n  /// @param y The int128 to be casted\\r\\n  /// @return z = -y, now type uint128\\r\\n  function revToUint128(int128 y) internal pure returns (uint128 z) {\\r\\n      return type(uint128).max - uint128(y) + 1;\\r\\n  }\\r\\n\\r\\n  /// @notice Cast a uint256 to a uint160, revert on overflow\\r\\n  /// @param y The uint256 to be downcasted\\r\\n  /// @return z The downcasted integer, now type uint160\\r\\n  function toUint160(uint256 y) internal pure returns (uint160 z) {\\r\\n    require((z = uint160(y)) == y);\\r\\n  }\\r\\n\\r\\n  /// @notice Cast a uint256 to a int256, revert on overflow\\r\\n  /// @param y The uint256 to be casted\\r\\n  /// @return z The casted integer, now type int256\\r\\n  function toInt256(uint256 y) internal pure returns (int256 z) {\\r\\n    require(y < 2**255);\\r\\n    z = int256(y);\\r\\n  }\\r\\n\\r\\n  /// @notice Cast a uint256 to a int256 and reverses the sign, revert on overflow\\r\\n  /// @param y The uint256 to be casted\\r\\n  /// @return z = -y, now type int256\\r\\n  function revToInt256(uint256 y) internal pure returns (int256 z) {\\r\\n    require(y < 2**255);\\r\\n    z = -int256(y);\\r\\n  }\\r\\n\\r\\n  /// @notice Cast a int256 to a uint256 and reverses the sign.\\r\\n  /// @param y The int256 to be casted\\r\\n  /// @return z = -y, now type uint256\\r\\n  function revToUint256(int256 y) internal pure returns (uint256 z) {\\r\\n      return type(uint256).max - uint256(y) + 1;\\r\\n  }\\r\\n}\\r\\n\",\"keccak256\":\"0x9a6ec130d3ef15a70c1caf8daa9870c9b54cf69dfc09208ed8cdc3743a6106bf\",\"license\":\"GPL-2.0-or-later\"},\"contracts/KyberQuoter/lib/SwapMath.sol\":{\"content\":\"// SPDX-License-Identifier: MIT\\r\\npragma solidity >=0.7.6;\\r\\n\\r\\nimport '../lib/Math.sol';\\r\\nimport './SafeCast.sol';\\r\\n\\r\\n\\r\\nlibrary QuadMath {\\r\\n  // our equation is ax^2 - 2bx + c = 0, where a, b and c > 0\\r\\n  // the qudratic formula to obtain the smaller root is (2b - sqrt((2*b)^2 - 4ac)) / 2a\\r\\n  // which can be simplified to (b - sqrt(b^2 - ac)) / a\\r\\n  function getSmallerRootOfQuadEqn(\\r\\n    uint256 a,\\r\\n    uint256 b,\\r\\n    uint256 c\\r\\n  ) internal pure returns (uint256 smallerRoot) {\\r\\n    smallerRoot = (b - sqrt(b * b - a * c)) / a;\\r\\n  }\\r\\n\\r\\n  // babylonian method (https://en.wikipedia.org/wiki/Methods_of_computing_square_roots#Babylonian_method)\\r\\n  function sqrt(uint256 y) internal pure returns (uint256 z) {\\r\\n      if (y > 3) {\\r\\n        z = y;\\r\\n        uint256 x = y / 2 + 1;\\r\\n        while (x < z) {\\r\\n          z = x;\\r\\n          x = (y / x + x) / 2;\\r\\n        }\\r\\n      } else if (y != 0) {\\r\\n        z = 1;\\r\\n      }\\r\\n    }\\r\\n}\\r\\n\\r\\n\\r\\n/// @title Contains helper functions for swaps\\r\\nlibrary SwapMath {\\r\\n  using SafeCast for uint256;\\r\\n  using SafeCast for int256;\\r\\n\\r\\n  /// @dev Computes the actual swap input / output amounts to be deducted or added,\\r\\n  /// the swap fee to be collected and the resulting sqrtP.\\r\\n  /// @notice nextSqrtP should not exceed targetSqrtP.\\r\\n  /// @param liquidity active base liquidity + reinvest liquidity\\r\\n  /// @param currentSqrtP current sqrt price\\r\\n  /// @param targetSqrtP sqrt price limit the new sqrt price can take\\r\\n  /// @param feeInFeeUnits swap fee in basis points\\r\\n  /// @param specifiedAmount the amount remaining to be used for the swap\\r\\n  /// @param isExactInput true if specifiedAmount refers to input amount, false if specifiedAmount refers to output amount\\r\\n  /// @param isToken0 true if specifiedAmount is in token0, false if specifiedAmount is in token1\\r\\n  /// @return usedAmount actual amount to be used for the swap\\r\\n  /// @return returnedAmount output qty to be accumulated if isExactInput = true, input qty if isExactInput = false\\r\\n  /// @return deltaL collected swap fee, to be incremented to reinvest liquidity\\r\\n  /// @return nextSqrtP the new sqrt price after the computed swap step\\r\\n  function computeSwapStep(\\r\\n    uint256 liquidity,\\r\\n    uint160 currentSqrtP,\\r\\n    uint160 targetSqrtP,\\r\\n    uint256 feeInFeeUnits,\\r\\n    int256 specifiedAmount,\\r\\n    bool isExactInput,\\r\\n    bool isToken0\\r\\n  )\\r\\n    internal\\r\\n    pure\\r\\n    returns (\\r\\n      int256 usedAmount,\\r\\n      int256 returnedAmount,\\r\\n      uint256 deltaL,\\r\\n      uint160 nextSqrtP\\r\\n    )\\r\\n  {\\r\\n    // in the event currentSqrtP == targetSqrtP because of tick movements, return\\r\\n    // eg. swapped up tick where specified price limit is on an initialised tick\\r\\n    // then swapping down tick will cause next tick to be the same as the current tick\\r\\n    if (currentSqrtP == targetSqrtP) return (0, 0, 0, currentSqrtP);\\r\\n    usedAmount = calcReachAmount(\\r\\n      liquidity,\\r\\n      currentSqrtP,\\r\\n      targetSqrtP,\\r\\n      feeInFeeUnits,\\r\\n      isExactInput,\\r\\n      isToken0\\r\\n    );\\r\\n\\r\\n    if (\\r\\n      (isExactInput && usedAmount >= specifiedAmount) ||\\r\\n      (!isExactInput && usedAmount <= specifiedAmount)\\r\\n    ) {\\r\\n      usedAmount = specifiedAmount;\\r\\n    } else {\\r\\n      nextSqrtP = targetSqrtP;\\r\\n    }\\r\\n\\r\\n    uint256 absDelta = usedAmount >= 0 ? uint256(usedAmount) : usedAmount.revToUint256();\\r\\n    if (nextSqrtP == 0) {\\r\\n      deltaL = estimateIncrementalLiquidity(\\r\\n        absDelta,\\r\\n        liquidity,\\r\\n        currentSqrtP,\\r\\n        feeInFeeUnits,\\r\\n        isExactInput,\\r\\n        isToken0\\r\\n      );\\r\\n      nextSqrtP = calcFinalPrice(absDelta, liquidity, deltaL, currentSqrtP, isExactInput, isToken0)\\r\\n      .toUint160();\\r\\n    } else {\\r\\n      deltaL = calcIncrementalLiquidity(\\r\\n        absDelta,\\r\\n        liquidity,\\r\\n        currentSqrtP,\\r\\n        nextSqrtP,\\r\\n        isExactInput,\\r\\n        isToken0\\r\\n      );\\r\\n    }\\r\\n    returnedAmount = calcReturnedAmount(\\r\\n      liquidity,\\r\\n      currentSqrtP,\\r\\n      nextSqrtP,\\r\\n      deltaL,\\r\\n      isExactInput,\\r\\n      isToken0\\r\\n    );\\r\\n  }\\r\\n\\r\\n  /// @dev calculates the amount needed to reach targetSqrtP from currentSqrtP\\r\\n  /// @dev we cast currentSqrtP and targetSqrtP to uint256 as they are multiplied by TWO_FEE_UNITS or feeInFeeUnits\\r\\n  function calcReachAmount(\\r\\n    uint256 liquidity,\\r\\n    uint256 currentSqrtP,\\r\\n    uint256 targetSqrtP,\\r\\n    uint256 feeInFeeUnits,\\r\\n    bool isExactInput,\\r\\n    bool isToken0\\r\\n  ) internal pure returns (int256 reachAmount) {\\r\\n    uint256 absPriceDiff;\\r\\n    absPriceDiff = (currentSqrtP >= targetSqrtP)\\r\\n        ? (currentSqrtP - targetSqrtP)\\r\\n        : (targetSqrtP - currentSqrtP);\\r\\n    if (isExactInput) {\\r\\n      // we round down so that we avoid taking giving away too much for the specified input\\r\\n      // ie. require less input qty to move ticks\\r\\n      if (isToken0) {\\r\\n        // numerator = 2 * liquidity * absPriceDiff\\r\\n        // denominator = currentSqrtP * (2 * targetSqrtP - currentSqrtP * feeInFeeUnits / FEE_UNITS)\\r\\n        // overflow should not happen because the absPriceDiff is capped to ~5%\\r\\n        uint256 denominator = TWO_FEE_UNITS * targetSqrtP - feeInFeeUnits * currentSqrtP;\\r\\n        uint256 numerator = FullMath.mulDivFloor(\\r\\n          liquidity,\\r\\n          TWO_FEE_UNITS * absPriceDiff,\\r\\n          denominator\\r\\n        );\\r\\n        reachAmount = FullMath.mulDivFloor(numerator, TWO_POW_96, currentSqrtP).toInt256();\\r\\n      } else {\\r\\n        // numerator = 2 * liquidity * absPriceDiff * currentSqrtP\\r\\n        // denominator = 2 * currentSqrtP - targetSqrtP * feeInFeeUnits / FEE_UNITS\\r\\n        // overflow should not happen because the absPriceDiff is capped to ~5%\\r\\n        uint256 denominator = TWO_FEE_UNITS * currentSqrtP - feeInFeeUnits * targetSqrtP;\\r\\n        uint256 numerator = FullMath.mulDivFloor(\\r\\n          liquidity,\\r\\n          TWO_FEE_UNITS * absPriceDiff,\\r\\n          denominator\\r\\n        );\\r\\n        reachAmount = FullMath.mulDivFloor(numerator, currentSqrtP, TWO_POW_96).toInt256();\\r\\n      }\\r\\n    } else {\\r\\n      // we will perform negation as the last step\\r\\n      // we round down so that we require less output qty to move ticks\\r\\n      if (isToken0) {\\r\\n        // numerator: (liquidity)(absPriceDiff)(2 * currentSqrtP - deltaL * (currentSqrtP + targetSqrtP))\\r\\n        // denominator: (currentSqrtP * targetSqrtP) * (2 * currentSqrtP - deltaL * targetSqrtP)\\r\\n        // overflow should not happen because the absPriceDiff is capped to ~5%\\r\\n        uint256 denominator = TWO_FEE_UNITS * currentSqrtP - feeInFeeUnits * targetSqrtP;\\r\\n        uint256 numerator = denominator - feeInFeeUnits * currentSqrtP;\\r\\n        numerator = FullMath.mulDivFloor(liquidity << RES_96, numerator, denominator);\\r\\n        reachAmount = (FullMath.mulDivFloor(numerator, absPriceDiff, currentSqrtP) / targetSqrtP)\\r\\n        .revToInt256();\\r\\n      } else {\\r\\n        // numerator: liquidity * absPriceDiff * (TWO_FEE_UNITS * targetSqrtP - feeInFeeUnits * (targetSqrtP + currentSqrtP))\\r\\n        // denominator: (TWO_FEE_UNITS * targetSqrtP - feeInFeeUnits * currentSqrtP)\\r\\n        // overflow should not happen because the absPriceDiff is capped to ~5%\\r\\n        uint256 denominator = TWO_FEE_UNITS * targetSqrtP - feeInFeeUnits * currentSqrtP;\\r\\n        uint256 numerator = denominator - feeInFeeUnits * targetSqrtP;\\r\\n        numerator = FullMath.mulDivFloor(liquidity, numerator, denominator);\\r\\n        reachAmount = FullMath.mulDivFloor(numerator, absPriceDiff, TWO_POW_96).revToInt256();\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @dev estimates deltaL, the swap fee to be collected based on amount specified\\r\\n  /// for the final swap step to be performed,\\r\\n  /// where the next (temporary) tick will not be crossed\\r\\n  function estimateIncrementalLiquidity(\\r\\n    uint256 absDelta,\\r\\n    uint256 liquidity,\\r\\n    uint160 currentSqrtP,\\r\\n    uint256 feeInFeeUnits,\\r\\n    bool isExactInput,\\r\\n    bool isToken0\\r\\n  ) internal pure returns (uint256 deltaL) {\\r\\n    if (isExactInput) {\\r\\n      if (isToken0) {\\r\\n        // deltaL = feeInFeeUnits * absDelta * currentSqrtP / 2\\r\\n        deltaL = FullMath.mulDivFloor(\\r\\n          currentSqrtP,\\r\\n          absDelta * feeInFeeUnits,\\r\\n          TWO_FEE_UNITS << RES_96\\r\\n        );\\r\\n      } else {\\r\\n        // deltaL = feeInFeeUnits * absDelta * / (currentSqrtP * 2)\\r\\n        // Because nextSqrtP = (liquidity + absDelta / currentSqrtP) * currentSqrtP / (liquidity + deltaL)\\r\\n        // so we round up deltaL, to round down nextSqrtP\\r\\n        deltaL = FullMath.mulDivFloor(\\r\\n          TWO_POW_96,\\r\\n          absDelta * feeInFeeUnits,\\r\\n          TWO_FEE_UNITS * currentSqrtP\\r\\n        );\\r\\n      }\\r\\n    } else {\\r\\n      // obtain the smaller root of the quadratic equation\\r\\n      // ax^2 - 2bx + c = 0 such that b > 0, and x denotes deltaL\\r\\n      uint256 a = feeInFeeUnits;\\r\\n      uint256 b = (FEE_UNITS - feeInFeeUnits) * liquidity;\\r\\n      uint256 c = feeInFeeUnits * liquidity * absDelta;\\r\\n      if (isToken0) {\\r\\n        // a = feeInFeeUnits\\r\\n        // b = (FEE_UNITS - feeInFeeUnits) * liquidity - FEE_UNITS * absDelta * currentSqrtP\\r\\n        // c = feeInFeeUnits * liquidity * absDelta * currentSqrtP\\r\\n        b -= FullMath.mulDivFloor(FEE_UNITS * absDelta, currentSqrtP, TWO_POW_96);\\r\\n        c = FullMath.mulDivFloor(c, currentSqrtP, TWO_POW_96);\\r\\n      } else {\\r\\n        // a = feeInFeeUnits\\r\\n        // b = (FEE_UNITS - feeInFeeUnits) * liquidity - FEE_UNITS * absDelta / currentSqrtP\\r\\n        // c = liquidity * feeInFeeUnits * absDelta / currentSqrtP\\r\\n        b -= FullMath.mulDivFloor(FEE_UNITS * absDelta, TWO_POW_96, currentSqrtP);\\r\\n        c = FullMath.mulDivFloor(c, TWO_POW_96, currentSqrtP);\\r\\n      }\\r\\n      deltaL = QuadMath.getSmallerRootOfQuadEqn(a, b, c);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @dev calculates deltaL, the swap fee to be collected for an intermediate swap step,\\r\\n  /// where the next (temporary) tick will be crossed\\r\\n  function calcIncrementalLiquidity(\\r\\n    uint256 absDelta,\\r\\n    uint256 liquidity,\\r\\n    uint160 currentSqrtP,\\r\\n    uint160 nextSqrtP,\\r\\n    bool isExactInput,\\r\\n    bool isToken0\\r\\n  ) internal pure returns (uint256 deltaL) {\\r\\n    if (isToken0) {\\r\\n      // deltaL = nextSqrtP * (liquidity / currentSqrtP +/- absDelta)) - liquidity\\r\\n      // needs to be minimum\\r\\n      uint256 tmp1 = FullMath.mulDivFloor(liquidity, TWO_POW_96, currentSqrtP);\\r\\n      uint256 tmp2 = isExactInput ? tmp1 + absDelta : tmp1 - absDelta;\\r\\n      uint256 tmp3 = FullMath.mulDivFloor(nextSqrtP, tmp2, TWO_POW_96);\\r\\n      // in edge cases where liquidity or absDelta is small\\r\\n      // liquidity might be greater than nextSqrtP * ((liquidity / currentSqrtP) +/- absDelta))\\r\\n      // due to rounding\\r\\n      deltaL = (tmp3 > liquidity) ? tmp3 - liquidity : 0;\\r\\n    } else {\\r\\n      // deltaL = (liquidity * currentSqrtP +/- absDelta) / nextSqrtP - liquidity\\r\\n      // needs to be minimum\\r\\n      uint256 tmp1 = FullMath.mulDivFloor(liquidity, currentSqrtP, TWO_POW_96);\\r\\n      uint256 tmp2 = isExactInput ? tmp1 + absDelta : tmp1 - absDelta;\\r\\n      uint256 tmp3 = FullMath.mulDivFloor(tmp2, TWO_POW_96, nextSqrtP);\\r\\n      // in edge cases where liquidity or absDelta is small\\r\\n      // liquidity might be greater than nextSqrtP * ((liquidity / currentSqrtP) +/- absDelta))\\r\\n      // due to rounding\\r\\n      deltaL = (tmp3 > liquidity) ? tmp3 - liquidity : 0;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @dev calculates the sqrt price of the final swap step\\r\\n  /// where the next (temporary) tick will not be crossed\\r\\n  function calcFinalPrice(\\r\\n    uint256 absDelta,\\r\\n    uint256 liquidity,\\r\\n    uint256 deltaL,\\r\\n    uint160 currentSqrtP,\\r\\n    bool isExactInput,\\r\\n    bool isToken0\\r\\n  ) internal pure returns (uint256) {\\r\\n    if (isToken0) {\\r\\n      // if isExactInput: swap 0 -> 1, sqrtP decreases, we round up\\r\\n      // else swap: 1 -> 0, sqrtP increases, we round down\\r\\n      uint256 tmp = FullMath.mulDivFloor(absDelta, currentSqrtP, TWO_POW_96);\\r\\n      if (isExactInput) {\\r\\n        return FullMath.mulDivCeiling(liquidity + deltaL, currentSqrtP, liquidity + tmp);\\r\\n      } else {\\r\\n        return FullMath.mulDivFloor(liquidity + deltaL, currentSqrtP, liquidity - tmp);\\r\\n      }\\r\\n    } else {\\r\\n      // if isExactInput: swap 1 -> 0, sqrtP increases, we round down\\r\\n      // else swap: 0 -> 1, sqrtP decreases, we round up\\r\\n      if (isExactInput) {\\r\\n        uint256 tmp = FullMath.mulDivFloor(absDelta, TWO_POW_96, currentSqrtP);\\r\\n        return FullMath.mulDivFloor(liquidity + tmp, currentSqrtP, liquidity + deltaL);\\r\\n      } else {\\r\\n        uint256 tmp = FullMath.mulDivFloor(absDelta, TWO_POW_96, currentSqrtP);\\r\\n        return FullMath.mulDivCeiling(liquidity - tmp, currentSqrtP, liquidity + deltaL);\\r\\n      }\\r\\n    }\\r\\n  }\\r\\n\\r\\n  /// @dev calculates returned output | input tokens in exchange for specified amount\\r\\n  /// @dev round down when calculating returned output (isExactInput) so we avoid sending too much\\r\\n  /// @dev round up when calculating returned input (!isExactInput) so we get desired output amount\\r\\n  function calcReturnedAmount(\\r\\n    uint256 liquidity,\\r\\n    uint160 currentSqrtP,\\r\\n    uint160 nextSqrtP,\\r\\n    uint256 deltaL,\\r\\n    bool isExactInput,\\r\\n    bool isToken0\\r\\n  ) internal pure returns (int256 returnedAmount) {\\r\\n    if (isToken0) {\\r\\n      if (isExactInput) {\\r\\n        // minimise actual output (<0, make less negative) so we avoid sending too much\\r\\n        // returnedAmount = deltaL * nextSqrtP - liquidity * (currentSqrtP - nextSqrtP)\\r\\n        returnedAmount =\\r\\n          FullMath.mulDivCeiling(deltaL, nextSqrtP, TWO_POW_96).toInt256() +\\r\\n          FullMath.mulDivFloor(liquidity, currentSqrtP - nextSqrtP, TWO_POW_96).revToInt256();\\r\\n      } else {\\r\\n        // maximise actual input (>0) so we get desired output amount\\r\\n        // returnedAmount = deltaL * nextSqrtP + liquidity * (nextSqrtP - currentSqrtP)\\r\\n        returnedAmount =\\r\\n          FullMath.mulDivCeiling(deltaL, nextSqrtP, TWO_POW_96).toInt256() +\\r\\n          FullMath.mulDivCeiling(liquidity, nextSqrtP - currentSqrtP, TWO_POW_96).toInt256();\\r\\n      }\\r\\n    } else {\\r\\n      // returnedAmount = (liquidity + deltaL)/nextSqrtP - (liquidity)/currentSqrtP\\r\\n      // if exactInput, minimise actual output (<0, make less negative) so we avoid sending too much\\r\\n      // if exactOutput, maximise actual input (>0) so we get desired output amount\\r\\n      returnedAmount =\\r\\n        FullMath.mulDivCeiling(liquidity + deltaL, TWO_POW_96, nextSqrtP).toInt256() +\\r\\n        FullMath.mulDivFloor(liquidity, TWO_POW_96, currentSqrtP).revToInt256();\\r\\n    }\\r\\n\\r\\n    if (isExactInput && returnedAmount == 1) {\\r\\n      // rounding make returnedAmount == 1\\r\\n      returnedAmount = 0;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\",\"keccak256\":\"0x162e82ae0c8d2797fbcf0808d315dd0eb94e6ee0f0cc5f570301f5995bf5e0d5\",\"license\":\"MIT\"},\"contracts/UniV3Quoter/interfaces/IUniswapV3StaticQuoter.sol\":{\"content\":\"// SPDX-License-Identifier: GPL-2.0-or-later\\r\\npragma solidity >=0.7.5;\\r\\npragma abicoder v2;\\r\\n\\r\\ninterface IUniswapV3StaticQuoter {\\r\\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\\r\\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\\r\\n    /// @param amountIn The amount of the first token to swap\\r\\n    /// @return amountOut The amount of the last token that would be received\\r\\n    function quoteExactInput(bytes memory path, uint256 amountIn)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 amountOut);\\r\\n\\r\\n    struct QuoteExactInputSingleParams {\\r\\n        address tokenIn;\\r\\n        address tokenOut;\\r\\n        uint256 amountIn;\\r\\n        uint24 fee;\\r\\n        uint160 sqrtPriceLimitX96;\\r\\n    }\\r\\n\\r\\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\\r\\n    /// @param params The params for the quote, encoded as `QuoteExactInputSingleParams`\\r\\n    /// tokenIn The token being swapped in\\r\\n    /// tokenOut The token being swapped out\\r\\n    /// fee The fee of the token pool to consider for the pair\\r\\n    /// amountIn The desired input amount\\r\\n    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\\r\\n    /// @return amountOut The amount of `tokenOut` that would be received\\r\\n    function quoteExactInputSingle(QuoteExactInputSingleParams memory params)\\r\\n        external\\r\\n        view\\r\\n        returns (uint256 amountOut);\\r\\n}\",\"keccak256\":\"0x21c66d53d0f2608c5f10c594e45184036f6899dcc8bcdcd2c7e8aa738bf30337\",\"license\":\"GPL-2.0-or-later\"}},\"version\":1}",
  "bytecode": "0x60a06040523480156200001157600080fd5b50604051620026a9380380620026a983398101604081905262000034916200004a565b60601b6001600160601b0319166080526200007a565b6000602082840312156200005c578081fd5b81516001600160a01b038116811462000073578182fd5b9392505050565b60805160601c612611620000986000398061143252506126116000f3fe608060405234801561001057600080fd5b50600436106100415760003560e01c806390405d3614610046578063c6a5026a14610070578063cdca175314610090575b600080fd5b6100596100543660046123a9565b6100a3565b60405161006792919061256d565b60405180910390f35b61008361007e3660046124ab565b61043b565b60405161006791906125b2565b61008361009e3660046123ff565b610557565b6000808361011257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601e60248201527f616d6f756e745370656369666965642063616e6e6f74206265207a65726f0000604482015290519081900360640190fd5b61011a61232e565b84815285151560c082018190526000861360e08301819052141561013e888261062c565b600290810b810b608088015290810b900b606086015273ffffffffffffffffffffffffffffffffffffffff16604085018190526fffffffffffffffffffffffffffffffff91821661012086015291166101008401526101a09082908790610773565b60008873ffffffffffffffffffffffffffffffffffffffff1663c79a590e6040518163ffffffff1660e01b815260040160206040518083038186803b1580156101e857600080fd5b505afa1580156101fc573d6000803e3d6000fd5b505050506040513d602081101561021257600080fd5b505190505b82511580159061025757508573ffffffffffffffffffffffffffffffffffffffff16836040015173ffffffffffffffffffffffffffffffffffffffff1614155b1561040b57600061027184606001518560800151856108ac565b905061027c8161091b565b73ffffffffffffffffffffffffffffffffffffffff90811660a08601819052908816811184151514156102ac5750865b60008060006102f3886101200151896101000151016fffffffffffffffffffffffffffffffff168960400151868962ffffff168c600001518d60e001518e60c00151610cae565b73ffffffffffffffffffffffffffffffffffffffff1660408c01528a518390038b5260208b018051830190529194509250905061032f81610dfb565b61012089018051919091016fffffffffffffffffffffffffffffffff16905250505060a0850151604086015173ffffffffffffffffffffffffffffffffffffffff918216911614905061039b576103898460400151610e1a565b600290810b900b60608501525061040b565b826103a957600181036103ab565b805b600290810b810b6060860152608085015182820b910b146103cc5750610217565b6103e18a8560800151866101000151866111e6565b600290810b900b60808601526fffffffffffffffffffffffffffffffff1661010085015250610217565b8761041e5760208301518351880361042b565b8260000151870383602001515b909a909950975050505050505050565b60208101518151606083015160009273ffffffffffffffffffffffffffffffffffffffff8082169084161092849261047392906113f2565b905073ffffffffffffffffffffffffffffffffffffffff81166104cb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104c29061257b565b60405180910390fd5b60008061053483856104e089604001516114c3565b60808a015173ffffffffffffffffffffffffffffffffffffffff161561050a578960800151610054565b876105295773fffd8963efd1fc6a506488495d951d5263988d25610054565b6401000276a46100a3565b9150915083610546578160000361054b565b806000035b9450505050505b919050565b6000805b6000806000610569876114f5565b92509250925060006105e86040518060a001604052808673ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff1681526020018981526020018462ffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff1681525061043b565b965050600190930192856105fb88611526565b15610610576106098861152e565b975061061d565b8695505050505050610626565b5050505061055b565b92915050565b60008060008060008673ffffffffffffffffffffffffffffffffffffffff1663217ac2376040518163ffffffff1660e01b815260040160806040518083038186803b15801561067a57600080fd5b505afa15801561068e573d6000803e3d6000fd5b505050506040513d60808110156106a457600080fd5b508051602082015160409283015183517fab612f2b0000000000000000000000000000000000000000000000000000000081529351929650909450925073ffffffffffffffffffffffffffffffffffffffff89169163ab612f2b916004808301926060929190829003018186803b15801561071e57600080fd5b505afa158015610732573d6000803e3d6000fd5b505050506040513d606081101561074857600080fd5b50805160209091015190955093508515610769576107668782611563565b90505b9295509295909350565b6000836107d4578173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161080156107cf57506401000276a373ffffffffffffffffffffffffffffffffffffffff8416115b610838565b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16118015610838575073fffd8963efd1fc6a506488495d951d5263988d2673ffffffffffffffffffffffffffffffffffffffff8416105b9050806108a657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f7371727450726963654c696d6974206f7574206f6620626f756e647300000000604482015290519081900360640190fd5b50505050565b818180156108c35750836101e00160020b8160020b135b156108d357506101e08301610914565b811580156108ea57506101e0840360020b8160020b125b1561091457507ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe2083015b9392505050565b60008060008360020b12610932578260020b61093a565b8260020b6000035b9050620d89e88111156109ae57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600160248201527f5400000000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b6000600182166109cf577001000000000000000000000000000000006109e1565b6ffffcb933bd6fad37aa2d162d1a5940015b70ffffffffffffffffffffffffffffffffff1690506002821615610a15576ffff97272373d413259a46990580e213a0260801c5b6004821615610a34576ffff2e50f5f656932ef12357cf3c7fdcc0260801c5b6008821615610a53576fffe5caca7e10e4e61c3624eaa0941cd00260801c5b6010821615610a72576fffcb9843d60f6159c9db58835c9266440260801c5b6020821615610a91576fff973b41fa98c081472e6896dfb254c00260801c5b6040821615610ab0576fff2ea16466c96a3843ec78b326b528610260801c5b6080821615610acf576ffe5dee046a99a2a811c461f1969c30530260801c5b610100821615610aef576ffcbe86c7900a88aedcffc83b479aa3a40260801c5b610200821615610b0f576ff987a7253ac413176f2b074cf7815e540260801c5b610400821615610b2f576ff3392b0822b70005940c7a398e4b70f30260801c5b610800821615610b4f576fe7159475a2c29b7443b29c7fa6e889d90260801c5b611000821615610b6f576fd097f3bdfd2022b8845ad8f792aa58250260801c5b612000821615610b8f576fa9f746462d870fdf8a65dc1f90e061e50260801c5b614000821615610baf576f70d869a156d2a1b890bb3df62baf32f70260801c5b618000821615610bcf576f31be135f97d08fd981231505542fcfa60260801c5b62010000821615610bf0576f09aa508b5b7a84e1c677de54f3e99bc90260801c5b62020000821615610c10576e5d6af8dedb81196699c329225ee6040260801c5b62040000821615610c2f576d2216e584f5fa1ea926041bedfe980260801c5b62080000821615610c4c576b048a170391f7dc42444e8fa20260801c5b60008460020b1315610c8557807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81610c8157fe5b0490505b640100000000810615610c99576001610c9c565b60005b60ff16602082901c0192505050919050565b6000806000808873ffffffffffffffffffffffffffffffffffffffff168a73ffffffffffffffffffffffffffffffffffffffff161415610cf957506000925082915081905088610ded565b610d338b8b73ffffffffffffffffffffffffffffffffffffffff168b73ffffffffffffffffffffffffffffffffffffffff168b8a8a6115ee565b9350858015610d425750868412155b80610d56575085158015610d565750868413155b15610d6357869350610d66565b50875b600080851215610d7e57610d7985611733565b610d80565b845b905073ffffffffffffffffffffffffffffffffffffffff8216610dca57610dab818d8d8c8b8b61173a565b9250610dc3610dbe828e868f8c8c6118bc565b611a02565b9150610ddb565b610dd8818d8d858b8b611a25565b92505b610de98c8c84868b8b611b59565b9350505b975097509750979350505050565b806fffffffffffffffffffffffffffffffff8116811461055257600080fd5b60006401000276a373ffffffffffffffffffffffffffffffffffffffff831610801590610e70575073fffd8963efd1fc6a506488495d951d5263988d2673ffffffffffffffffffffffffffffffffffffffff8316105b610edb57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600160248201527f5200000000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b77ffffffffffffffffffffffffffffffffffffffff00000000602083901b166fffffffffffffffffffffffffffffffff811160071b81811c67ffffffffffffffff811160061b90811c63ffffffff811160051b90811c61ffff811160041b90811c60ff8111600390811b91821c600f811160021b90811c918211600190811b92831c97908811961790941790921717909117171760808110610f8557607f810383901c9150610f8f565b80607f0383901b91505b908002607f81811c60ff83811c9190911c800280831c81831c1c800280841c81841c1c800280851c81851c1c800280861c81861c1c800280871c81871c1c800280881c81881c1c800280891c81891c1c8002808a1c818a1c1c8002808b1c818b1c1c8002808c1c818c1c1c8002808d1c818d1c1c8002808e1c9c81901c9c909c1c80029c8d901c9e9d7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808f0160401b60c09190911c678000000000000000161760c19b909b1c674000000000000000169a909a1760c29990991c672000000000000000169890981760c39790971c671000000000000000169690961760c49590951c670800000000000000169490941760c59390931c670400000000000000169290921760c69190911c670200000000000000161760c79190911c670100000000000000161760c89190911c6680000000000000161760c99190911c6640000000000000161760ca9190911c6620000000000000161760cb9190911c6610000000000000161760cc9190911c6608000000000000161760cd9190911c66040000000000001617693627a301d71055774c8581027ffffffffffffffffffffffffffffffffffd709b7e5480fba5a50fed5e62ffc5568101608090811d906fdb2df09e81959a81455e260799a0632f8301901d600281810b9083900b146111d7578873ffffffffffffffffffffffffffffffffffffffff166111ae8261091b565b73ffffffffffffffffffffffffffffffffffffffff1611156111d057816111d2565b805b6111d9565b815b9998505050505050505050565b60008060008673ffffffffffffffffffffffffffffffffffffffff1663f30dba93876040518263ffffffff1660e01b8152600401808260020b815260200191505060806040518083038186803b15801561123f57600080fd5b505afa158015611253573d6000803e3d6000fd5b505050506040513d608081101561126957600080fd5b50602001519050831561131857604080517fc0ac75cf000000000000000000000000000000000000000000000000000000008152600288900b6004820152815173ffffffffffffffffffffffffffffffffffffffff8a169263c0ac75cf9260248082019391829003018186803b1580156112e257600080fd5b505afa1580156112f6573d6000803e3d6000fd5b505050506040513d604081101561130c57600080fd5b506020015191506113b6565b604080517fc0ac75cf000000000000000000000000000000000000000000000000000000008152600288900b6004820152815173ffffffffffffffffffffffffffffffffffffffff8a169263c0ac75cf9260248082019391829003018186803b15801561138457600080fd5b505afa158015611398573d6000803e3d6000fd5b505050506040513d60408110156113ae57600080fd5b505191506000035b6113e685600083600f0b12156113d7576113d283600f0b611cc7565b6113d9565b825b600084600f0b1215611cdf565b92505094509492505050565b6040517f1698ee8200000000000000000000000000000000000000000000000000000000815260009073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001690631698ee829061146b90879087908790600401612538565b60206040518083038186803b15801561148357600080fd5b505afa158015611497573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114bb919061238d565b949350505050565b60007f800000000000000000000000000000000000000000000000000000000000000082106114f157600080fd5b5090565b600080806115038482611cf4565b9250611510846014611df4565b905061151d846017611cf4565b91509193909250565b516042111590565b80516060906106269083906017907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe901611ee4565b60008273ffffffffffffffffffffffffffffffffffffffff1663c0ac75cf836040518263ffffffff1660e01b8152600401808260020b8152602001915050604080518083038186803b1580156115b857600080fd5b505afa1580156115cc573d6000803e3d6000fd5b505050506040513d60408110156115e257600080fd5b50602001519392505050565b6000808587101561160157868603611605565b8587035b905083156116a557821561165e5760008786028762030d400203905060006116338a8462030d4002846120cb565b9050611655611650826c010000000000000000000000008c6120cb565b6114c3565b935050506116a0565b60008686028862030d4002039050600061167e8a8462030d4002846120cb565b905061169b611650828b6c010000000000000000000000006120cb565b935050505b611728565b82156116e75784860262030d4088020387860281036116c960608b901b82846120cb565b905061169b886116da83868d6120cb565b816116e157fe5b04612258565b84870262030d4087020386860281036117018a82846120cb565b905061172361171e82856c010000000000000000000000006120cb565b612258565b935050505b509695505050505050565b1960010190565b600082156117be5781156117815761177a73ffffffffffffffffffffffffffffffffffffffff86168886026e030d400000000000000000000000006120cb565b90506117b9565b6117b66c010000000000000000000000008589028773ffffffffffffffffffffffffffffffffffffffff1662030d40026120cb565b90505b6118b2565b83620186a081900387028782028902841561183f57611806620186a08b0273ffffffffffffffffffffffffffffffffffffffff8a166c010000000000000000000000006120cb565b82039150611838818973ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000006120cb565b90506118a7565b611872620186a08b026c0100000000000000000000000073ffffffffffffffffffffffffffffffffffffffff8b166120cb565b820391506118a4816c010000000000000000000000008a73ffffffffffffffffffffffffffffffffffffffff166120cb565b90505b61172383838361228d565b9695505050505050565b6000811561194e5760006118f4888673ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000006120cb565b90508315611929576119218688018673ffffffffffffffffffffffffffffffffffffffff16838a016122b1565b9150506118b2565b6119218688018673ffffffffffffffffffffffffffffffffffffffff16838a036120cb565b82156119ab576000611984886c010000000000000000000000008773ffffffffffffffffffffffffffffffffffffffff166120cb565b90506119218188018673ffffffffffffffffffffffffffffffffffffffff16888a016120cb565b60006119db886c010000000000000000000000008773ffffffffffffffffffffffffffffffffffffffff166120cb565b90506119218188038673ffffffffffffffffffffffffffffffffffffffff16888a016122b1565b8073ffffffffffffffffffffffffffffffffffffffff8116811461055257600080fd5b60008115611ac2576000611a5d876c010000000000000000000000008873ffffffffffffffffffffffffffffffffffffffff166120cb565b9050600084611a6e57888203611a72565b8882015b90506000611aa48773ffffffffffffffffffffffffffffffffffffffff16836c010000000000000000000000006120cb565b9050888111611ab4576000611ab8565b8881035b93505050506118b2565b6000611af2878773ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000006120cb565b9050600084611b0357888203611b07565b8882015b90506000611b39826c010000000000000000000000008973ffffffffffffffffffffffffffffffffffffffff166120cb565b9050888111611b49576000611723565b9790970398975050505050505050565b60008115611c40578215611bd357611b9a61171e8887890373ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000006120cb565b611bcb611650868873ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000006122b1565b019050611c3b565b611c066116508888880373ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000006122b1565b611c37611650868873ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000006122b1565b0190505b611ca8565b611c7161171e886c010000000000000000000000008973ffffffffffffffffffffffffffffffffffffffff166120cb565b611ca4611650868a016c010000000000000000000000008973ffffffffffffffffffffffffffffffffffffffff166122b1565b0190505b828015611cb55750806001145b156118b2575060009695505050505050565b6fffffffffffffffffffffffffffffffff0360010190565b600081611cee578284036114bb565b50500190565b600081826014011015611d6857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f746f416464726573735f6f766572666c6f770000000000000000000000000000604482015290519081900360640190fd5b8160140183511015611ddb57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f746f416464726573735f6f75744f66426f756e64730000000000000000000000604482015290519081900360640190fd5b5001602001516c01000000000000000000000000900490565b600081826003011015611e6857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f746f55696e7432345f6f766572666c6f77000000000000000000000000000000604482015290519081900360640190fd5b8160030183511015611edb57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f746f55696e7432345f6f75744f66426f756e6473000000000000000000000000604482015290519081900360640190fd5b50016003015190565b60608182601f011015611f5857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015290519081900360640190fd5b828284011015611fc957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015290519081900360640190fd5b8183018451101561203b57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f736c6963655f6f75744f66426f756e6473000000000000000000000000000000604482015290519081900360640190fd5b60608215801561205a57604051915060008252602082016040526120c2565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561209357805183526020928301920161207b565b5050858452601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016604052505b50949350505050565b600080807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff85870986860292508281109083900303905080612181576000841161217657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600760248201527f302064656e6f6d00000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b508290049050610914565b8084116121ef57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f64656e6f6d203c3d2070726f6431000000000000000000000000000000000000604482015290519081900360640190fd5b60008486880960026001871981018816978890046003810283188082028403028082028403028082028403028082028403028082028403029081029092039091026000889003889004909101858311909403939093029303949094049190911702949350505050565b60007f8000000000000000000000000000000000000000000000000000000000000000821061228657600080fd5b5060000390565b60008361229f838602858602036122dd565b8403816122a857fe5b04949350505050565b60006122be8484846120cb565b9050600082806122ca57fe5b8486091115610914576001019392505050565b60006003821115612320575080600160028204015b8181101561231a5780915060028182858161230957fe5b04018161231257fe5b0490506122f2565b50610552565b811561055257506001919050565b6040805161014081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052610100810182905261012081019190915290565b8035610552816125df565b60006020828403121561239e578081fd5b8151610914816125df565b600080600080608085870312156123be578283fd5b84356123c9816125df565b9350602085013580151581146123dd578384fd5b92506040850135915060608501356123f4816125df565b939692955090935050565b60008060408385031215612411578182fd5b823567ffffffffffffffff80821115612428578384fd5b818501915085601f83011261243b578384fd5b813560208282111561244957fe5b612479817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f850116016125bb565b9250818352878183860101111561248e578586fd5b818185018285013790820181019490945295939092013593505050565b600060a082840312156124bc578081fd5b60405160a0810181811067ffffffffffffffff821117156124d957fe5b60405282356124e7816125df565b815260208301356124f7816125df565b602082015260408381013590820152606083013562ffffff8116811461251b578283fd5b606082015261252c60808401612382565b60808201529392505050565b73ffffffffffffffffffffffffffffffffffffffff938416815291909216602082015262ffffff909116604082015260600190565b918252602082015260400190565b6020808252600e908201527f506f6f6c206e6f7420666f756e64000000000000000000000000000000000000604082015260600190565b90815260200190565b60405181810167ffffffffffffffff811182821017156125d757fe5b604052919050565b73ffffffffffffffffffffffffffffffffffffffff8116811461260157600080fd5b5056fea164736f6c6343000706000a",
  "deployedBytecode": "0x608060405234801561001057600080fd5b50600436106100415760003560e01c806390405d3614610046578063c6a5026a14610070578063cdca175314610090575b600080fd5b6100596100543660046123a9565b6100a3565b60405161006792919061256d565b60405180910390f35b61008361007e3660046124ab565b61043b565b60405161006791906125b2565b61008361009e3660046123ff565b610557565b6000808361011257604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601e60248201527f616d6f756e745370656369666965642063616e6e6f74206265207a65726f0000604482015290519081900360640190fd5b61011a61232e565b84815285151560c082018190526000861360e08301819052141561013e888261062c565b600290810b810b608088015290810b900b606086015273ffffffffffffffffffffffffffffffffffffffff16604085018190526fffffffffffffffffffffffffffffffff91821661012086015291166101008401526101a09082908790610773565b60008873ffffffffffffffffffffffffffffffffffffffff1663c79a590e6040518163ffffffff1660e01b815260040160206040518083038186803b1580156101e857600080fd5b505afa1580156101fc573d6000803e3d6000fd5b505050506040513d602081101561021257600080fd5b505190505b82511580159061025757508573ffffffffffffffffffffffffffffffffffffffff16836040015173ffffffffffffffffffffffffffffffffffffffff1614155b1561040b57600061027184606001518560800151856108ac565b905061027c8161091b565b73ffffffffffffffffffffffffffffffffffffffff90811660a08601819052908816811184151514156102ac5750865b60008060006102f3886101200151896101000151016fffffffffffffffffffffffffffffffff168960400151868962ffffff168c600001518d60e001518e60c00151610cae565b73ffffffffffffffffffffffffffffffffffffffff1660408c01528a518390038b5260208b018051830190529194509250905061032f81610dfb565b61012089018051919091016fffffffffffffffffffffffffffffffff16905250505060a0850151604086015173ffffffffffffffffffffffffffffffffffffffff918216911614905061039b576103898460400151610e1a565b600290810b900b60608501525061040b565b826103a957600181036103ab565b805b600290810b810b6060860152608085015182820b910b146103cc5750610217565b6103e18a8560800151866101000151866111e6565b600290810b900b60808601526fffffffffffffffffffffffffffffffff1661010085015250610217565b8761041e5760208301518351880361042b565b8260000151870383602001515b909a909950975050505050505050565b60208101518151606083015160009273ffffffffffffffffffffffffffffffffffffffff8082169084161092849261047392906113f2565b905073ffffffffffffffffffffffffffffffffffffffff81166104cb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016104c29061257b565b60405180910390fd5b60008061053483856104e089604001516114c3565b60808a015173ffffffffffffffffffffffffffffffffffffffff161561050a578960800151610054565b876105295773fffd8963efd1fc6a506488495d951d5263988d25610054565b6401000276a46100a3565b9150915083610546578160000361054b565b806000035b9450505050505b919050565b6000805b6000806000610569876114f5565b92509250925060006105e86040518060a001604052808673ffffffffffffffffffffffffffffffffffffffff1681526020018573ffffffffffffffffffffffffffffffffffffffff1681526020018981526020018462ffffff168152602001600073ffffffffffffffffffffffffffffffffffffffff1681525061043b565b965050600190930192856105fb88611526565b15610610576106098861152e565b975061061d565b8695505050505050610626565b5050505061055b565b92915050565b60008060008060008673ffffffffffffffffffffffffffffffffffffffff1663217ac2376040518163ffffffff1660e01b815260040160806040518083038186803b15801561067a57600080fd5b505afa15801561068e573d6000803e3d6000fd5b505050506040513d60808110156106a457600080fd5b508051602082015160409283015183517fab612f2b0000000000000000000000000000000000000000000000000000000081529351929650909450925073ffffffffffffffffffffffffffffffffffffffff89169163ab612f2b916004808301926060929190829003018186803b15801561071e57600080fd5b505afa158015610732573d6000803e3d6000fd5b505050506040513d606081101561074857600080fd5b50805160209091015190955093508515610769576107668782611563565b90505b9295509295909350565b6000836107d4578173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161080156107cf57506401000276a373ffffffffffffffffffffffffffffffffffffffff8416115b610838565b8173ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff16118015610838575073fffd8963efd1fc6a506488495d951d5263988d2673ffffffffffffffffffffffffffffffffffffffff8416105b9050806108a657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601c60248201527f7371727450726963654c696d6974206f7574206f6620626f756e647300000000604482015290519081900360640190fd5b50505050565b818180156108c35750836101e00160020b8160020b135b156108d357506101e08301610914565b811580156108ea57506101e0840360020b8160020b125b1561091457507ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe2083015b9392505050565b60008060008360020b12610932578260020b61093a565b8260020b6000035b9050620d89e88111156109ae57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600160248201527f5400000000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b6000600182166109cf577001000000000000000000000000000000006109e1565b6ffffcb933bd6fad37aa2d162d1a5940015b70ffffffffffffffffffffffffffffffffff1690506002821615610a15576ffff97272373d413259a46990580e213a0260801c5b6004821615610a34576ffff2e50f5f656932ef12357cf3c7fdcc0260801c5b6008821615610a53576fffe5caca7e10e4e61c3624eaa0941cd00260801c5b6010821615610a72576fffcb9843d60f6159c9db58835c9266440260801c5b6020821615610a91576fff973b41fa98c081472e6896dfb254c00260801c5b6040821615610ab0576fff2ea16466c96a3843ec78b326b528610260801c5b6080821615610acf576ffe5dee046a99a2a811c461f1969c30530260801c5b610100821615610aef576ffcbe86c7900a88aedcffc83b479aa3a40260801c5b610200821615610b0f576ff987a7253ac413176f2b074cf7815e540260801c5b610400821615610b2f576ff3392b0822b70005940c7a398e4b70f30260801c5b610800821615610b4f576fe7159475a2c29b7443b29c7fa6e889d90260801c5b611000821615610b6f576fd097f3bdfd2022b8845ad8f792aa58250260801c5b612000821615610b8f576fa9f746462d870fdf8a65dc1f90e061e50260801c5b614000821615610baf576f70d869a156d2a1b890bb3df62baf32f70260801c5b618000821615610bcf576f31be135f97d08fd981231505542fcfa60260801c5b62010000821615610bf0576f09aa508b5b7a84e1c677de54f3e99bc90260801c5b62020000821615610c10576e5d6af8dedb81196699c329225ee6040260801c5b62040000821615610c2f576d2216e584f5fa1ea926041bedfe980260801c5b62080000821615610c4c576b048a170391f7dc42444e8fa20260801c5b60008460020b1315610c8557807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff81610c8157fe5b0490505b640100000000810615610c99576001610c9c565b60005b60ff16602082901c0192505050919050565b6000806000808873ffffffffffffffffffffffffffffffffffffffff168a73ffffffffffffffffffffffffffffffffffffffff161415610cf957506000925082915081905088610ded565b610d338b8b73ffffffffffffffffffffffffffffffffffffffff168b73ffffffffffffffffffffffffffffffffffffffff168b8a8a6115ee565b9350858015610d425750868412155b80610d56575085158015610d565750868413155b15610d6357869350610d66565b50875b600080851215610d7e57610d7985611733565b610d80565b845b905073ffffffffffffffffffffffffffffffffffffffff8216610dca57610dab818d8d8c8b8b61173a565b9250610dc3610dbe828e868f8c8c6118bc565b611a02565b9150610ddb565b610dd8818d8d858b8b611a25565b92505b610de98c8c84868b8b611b59565b9350505b975097509750979350505050565b806fffffffffffffffffffffffffffffffff8116811461055257600080fd5b60006401000276a373ffffffffffffffffffffffffffffffffffffffff831610801590610e70575073fffd8963efd1fc6a506488495d951d5263988d2673ffffffffffffffffffffffffffffffffffffffff8316105b610edb57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600160248201527f5200000000000000000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b77ffffffffffffffffffffffffffffffffffffffff00000000602083901b166fffffffffffffffffffffffffffffffff811160071b81811c67ffffffffffffffff811160061b90811c63ffffffff811160051b90811c61ffff811160041b90811c60ff8111600390811b91821c600f811160021b90811c918211600190811b92831c97908811961790941790921717909117171760808110610f8557607f810383901c9150610f8f565b80607f0383901b91505b908002607f81811c60ff83811c9190911c800280831c81831c1c800280841c81841c1c800280851c81851c1c800280861c81861c1c800280871c81871c1c800280881c81881c1c800280891c81891c1c8002808a1c818a1c1c8002808b1c818b1c1c8002808c1c818c1c1c8002808d1c818d1c1c8002808e1c9c81901c9c909c1c80029c8d901c9e9d7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff808f0160401b60c09190911c678000000000000000161760c19b909b1c674000000000000000169a909a1760c29990991c672000000000000000169890981760c39790971c671000000000000000169690961760c49590951c670800000000000000169490941760c59390931c670400000000000000169290921760c69190911c670200000000000000161760c79190911c670100000000000000161760c89190911c6680000000000000161760c99190911c6640000000000000161760ca9190911c6620000000000000161760cb9190911c6610000000000000161760cc9190911c6608000000000000161760cd9190911c66040000000000001617693627a301d71055774c8581027ffffffffffffffffffffffffffffffffffd709b7e5480fba5a50fed5e62ffc5568101608090811d906fdb2df09e81959a81455e260799a0632f8301901d600281810b9083900b146111d7578873ffffffffffffffffffffffffffffffffffffffff166111ae8261091b565b73ffffffffffffffffffffffffffffffffffffffff1611156111d057816111d2565b805b6111d9565b815b9998505050505050505050565b60008060008673ffffffffffffffffffffffffffffffffffffffff1663f30dba93876040518263ffffffff1660e01b8152600401808260020b815260200191505060806040518083038186803b15801561123f57600080fd5b505afa158015611253573d6000803e3d6000fd5b505050506040513d608081101561126957600080fd5b50602001519050831561131857604080517fc0ac75cf000000000000000000000000000000000000000000000000000000008152600288900b6004820152815173ffffffffffffffffffffffffffffffffffffffff8a169263c0ac75cf9260248082019391829003018186803b1580156112e257600080fd5b505afa1580156112f6573d6000803e3d6000fd5b505050506040513d604081101561130c57600080fd5b506020015191506113b6565b604080517fc0ac75cf000000000000000000000000000000000000000000000000000000008152600288900b6004820152815173ffffffffffffffffffffffffffffffffffffffff8a169263c0ac75cf9260248082019391829003018186803b15801561138457600080fd5b505afa158015611398573d6000803e3d6000fd5b505050506040513d60408110156113ae57600080fd5b505191506000035b6113e685600083600f0b12156113d7576113d283600f0b611cc7565b6113d9565b825b600084600f0b1215611cdf565b92505094509492505050565b6040517f1698ee8200000000000000000000000000000000000000000000000000000000815260009073ffffffffffffffffffffffffffffffffffffffff7f00000000000000000000000000000000000000000000000000000000000000001690631698ee829061146b90879087908790600401612538565b60206040518083038186803b15801561148357600080fd5b505afa158015611497573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906114bb919061238d565b949350505050565b60007f800000000000000000000000000000000000000000000000000000000000000082106114f157600080fd5b5090565b600080806115038482611cf4565b9250611510846014611df4565b905061151d846017611cf4565b91509193909250565b516042111590565b80516060906106269083906017907fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe901611ee4565b60008273ffffffffffffffffffffffffffffffffffffffff1663c0ac75cf836040518263ffffffff1660e01b8152600401808260020b8152602001915050604080518083038186803b1580156115b857600080fd5b505afa1580156115cc573d6000803e3d6000fd5b505050506040513d60408110156115e257600080fd5b50602001519392505050565b6000808587101561160157868603611605565b8587035b905083156116a557821561165e5760008786028762030d400203905060006116338a8462030d4002846120cb565b9050611655611650826c010000000000000000000000008c6120cb565b6114c3565b935050506116a0565b60008686028862030d4002039050600061167e8a8462030d4002846120cb565b905061169b611650828b6c010000000000000000000000006120cb565b935050505b611728565b82156116e75784860262030d4088020387860281036116c960608b901b82846120cb565b905061169b886116da83868d6120cb565b816116e157fe5b04612258565b84870262030d4087020386860281036117018a82846120cb565b905061172361171e82856c010000000000000000000000006120cb565b612258565b935050505b509695505050505050565b1960010190565b600082156117be5781156117815761177a73ffffffffffffffffffffffffffffffffffffffff86168886026e030d400000000000000000000000006120cb565b90506117b9565b6117b66c010000000000000000000000008589028773ffffffffffffffffffffffffffffffffffffffff1662030d40026120cb565b90505b6118b2565b83620186a081900387028782028902841561183f57611806620186a08b0273ffffffffffffffffffffffffffffffffffffffff8a166c010000000000000000000000006120cb565b82039150611838818973ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000006120cb565b90506118a7565b611872620186a08b026c0100000000000000000000000073ffffffffffffffffffffffffffffffffffffffff8b166120cb565b820391506118a4816c010000000000000000000000008a73ffffffffffffffffffffffffffffffffffffffff166120cb565b90505b61172383838361228d565b9695505050505050565b6000811561194e5760006118f4888673ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000006120cb565b90508315611929576119218688018673ffffffffffffffffffffffffffffffffffffffff16838a016122b1565b9150506118b2565b6119218688018673ffffffffffffffffffffffffffffffffffffffff16838a036120cb565b82156119ab576000611984886c010000000000000000000000008773ffffffffffffffffffffffffffffffffffffffff166120cb565b90506119218188018673ffffffffffffffffffffffffffffffffffffffff16888a016120cb565b60006119db886c010000000000000000000000008773ffffffffffffffffffffffffffffffffffffffff166120cb565b90506119218188038673ffffffffffffffffffffffffffffffffffffffff16888a016122b1565b8073ffffffffffffffffffffffffffffffffffffffff8116811461055257600080fd5b60008115611ac2576000611a5d876c010000000000000000000000008873ffffffffffffffffffffffffffffffffffffffff166120cb565b9050600084611a6e57888203611a72565b8882015b90506000611aa48773ffffffffffffffffffffffffffffffffffffffff16836c010000000000000000000000006120cb565b9050888111611ab4576000611ab8565b8881035b93505050506118b2565b6000611af2878773ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000006120cb565b9050600084611b0357888203611b07565b8882015b90506000611b39826c010000000000000000000000008973ffffffffffffffffffffffffffffffffffffffff166120cb565b9050888111611b49576000611723565b9790970398975050505050505050565b60008115611c40578215611bd357611b9a61171e8887890373ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000006120cb565b611bcb611650868873ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000006122b1565b019050611c3b565b611c066116508888880373ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000006122b1565b611c37611650868873ffffffffffffffffffffffffffffffffffffffff166c010000000000000000000000006122b1565b0190505b611ca8565b611c7161171e886c010000000000000000000000008973ffffffffffffffffffffffffffffffffffffffff166120cb565b611ca4611650868a016c010000000000000000000000008973ffffffffffffffffffffffffffffffffffffffff166122b1565b0190505b828015611cb55750806001145b156118b2575060009695505050505050565b6fffffffffffffffffffffffffffffffff0360010190565b600081611cee578284036114bb565b50500190565b600081826014011015611d6857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601260248201527f746f416464726573735f6f766572666c6f770000000000000000000000000000604482015290519081900360640190fd5b8160140183511015611ddb57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601560248201527f746f416464726573735f6f75744f66426f756e64730000000000000000000000604482015290519081900360640190fd5b5001602001516c01000000000000000000000000900490565b600081826003011015611e6857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f746f55696e7432345f6f766572666c6f77000000000000000000000000000000604482015290519081900360640190fd5b8160030183511015611edb57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601460248201527f746f55696e7432345f6f75744f66426f756e6473000000000000000000000000604482015290519081900360640190fd5b50016003015190565b60608182601f011015611f5857604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015290519081900360640190fd5b828284011015611fc957604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f736c6963655f6f766572666c6f77000000000000000000000000000000000000604482015290519081900360640190fd5b8183018451101561203b57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152601160248201527f736c6963655f6f75744f66426f756e6473000000000000000000000000000000604482015290519081900360640190fd5b60608215801561205a57604051915060008252602082016040526120c2565b6040519150601f8416801560200281840101858101878315602002848b0101015b8183101561209357805183526020928301920161207b565b5050858452601f017fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe016604052505b50949350505050565b600080807fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff85870986860292508281109083900303905080612181576000841161217657604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600760248201527f302064656e6f6d00000000000000000000000000000000000000000000000000604482015290519081900360640190fd5b508290049050610914565b8084116121ef57604080517f08c379a000000000000000000000000000000000000000000000000000000000815260206004820152600e60248201527f64656e6f6d203c3d2070726f6431000000000000000000000000000000000000604482015290519081900360640190fd5b60008486880960026001871981018816978890046003810283188082028403028082028403028082028403028082028403028082028403029081029092039091026000889003889004909101858311909403939093029303949094049190911702949350505050565b60007f8000000000000000000000000000000000000000000000000000000000000000821061228657600080fd5b5060000390565b60008361229f838602858602036122dd565b8403816122a857fe5b04949350505050565b60006122be8484846120cb565b9050600082806122ca57fe5b8486091115610914576001019392505050565b60006003821115612320575080600160028204015b8181101561231a5780915060028182858161230957fe5b04018161231257fe5b0490506122f2565b50610552565b811561055257506001919050565b6040805161014081018252600080825260208201819052918101829052606081018290526080810182905260a0810182905260c0810182905260e08101829052610100810182905261012081019190915290565b8035610552816125df565b60006020828403121561239e578081fd5b8151610914816125df565b600080600080608085870312156123be578283fd5b84356123c9816125df565b9350602085013580151581146123dd578384fd5b92506040850135915060608501356123f4816125df565b939692955090935050565b60008060408385031215612411578182fd5b823567ffffffffffffffff80821115612428578384fd5b818501915085601f83011261243b578384fd5b813560208282111561244957fe5b612479817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0601f850116016125bb565b9250818352878183860101111561248e578586fd5b818185018285013790820181019490945295939092013593505050565b600060a082840312156124bc578081fd5b60405160a0810181811067ffffffffffffffff821117156124d957fe5b60405282356124e7816125df565b815260208301356124f7816125df565b602082015260408381013590820152606083013562ffffff8116811461251b578283fd5b606082015261252c60808401612382565b60808201529392505050565b73ffffffffffffffffffffffffffffffffffffffff938416815291909216602082015262ffffff909116604082015260600190565b918252602082015260400190565b6020808252600e908201527f506f6f6c206e6f7420666f756e64000000000000000000000000000000000000604082015260600190565b90815260200190565b60405181810167ffffffffffffffff811182821017156125d757fe5b604052919050565b73ffffffffffffffffffffffffffffffffffffffff8116811461260157600080fd5b5056fea164736f6c6343000706000a",
  "devdoc": {
    "kind": "dev",
    "methods": {
      "quoteExactInput(bytes,uint256)": {
        "params": {
          "amountIn": "The amount of the first token to swap",
          "path": "The path of the swap, i.e. each token pair and the pool fee"
        },
        "returns": {
          "amountOut": "The amount of the last token that would be received"
        }
      },
      "quoteExactInputSingle((address,address,uint256,uint24,uint160))": {
        "params": {
          "params": "The params for the quote, encoded as `QuoteExactInputSingleParams` tokenIn The token being swapped in tokenOut The token being swapped out fee The fee of the token pool to consider for the pair amountIn The desired input amount sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap"
        },
        "returns": {
          "amountOut": "The amount of `tokenOut` that would be received"
        }
      }
    },
    "version": 1
  },
  "userdoc": {
    "kind": "user",
    "methods": {
      "quoteExactInput(bytes,uint256)": {
        "notice": "Returns the amount out received for a given exact input swap without executing the swap"
      },
      "quoteExactInputSingle((address,address,uint256,uint24,uint160))": {
        "notice": "Returns the amount out received for a given exact input but for a swap of a single pool"
      }
    },
    "version": 1
  },
  "storageLayout": {
    "storage": [],
    "types": null
  }
}